// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gie_schema.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_gie_5fschema_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_gie_5fschema_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_gie_5fschema_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_gie_5fschema_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_gie_5fschema_2eproto;
namespace gie {
class EdgeType;
struct EdgeTypeDefaultTypeInternal;
extern EdgeTypeDefaultTypeInternal _EdgeType_default_instance_;
class GraphPartitionStrategy;
struct GraphPartitionStrategyDefaultTypeInternal;
extern GraphPartitionStrategyDefaultTypeInternal _GraphPartitionStrategy_default_instance_;
class GraphPropertyPartitionStrategy;
struct GraphPropertyPartitionStrategyDefaultTypeInternal;
extern GraphPropertyPartitionStrategyDefaultTypeInternal _GraphPropertyPartitionStrategy_default_instance_;
class Property;
struct PropertyDefaultTypeInternal;
extern PropertyDefaultTypeInternal _Property_default_instance_;
class PropertyPartitionByEntityStrategy;
struct PropertyPartitionByEntityStrategyDefaultTypeInternal;
extern PropertyPartitionByEntityStrategyDefaultTypeInternal _PropertyPartitionByEntityStrategy_default_instance_;
class PropertyPartitionByTypeStrategy;
struct PropertyPartitionByTypeStrategyDefaultTypeInternal;
extern PropertyPartitionByTypeStrategyDefaultTypeInternal _PropertyPartitionByTypeStrategy_default_instance_;
class Schema;
struct SchemaDefaultTypeInternal;
extern SchemaDefaultTypeInternal _Schema_default_instance_;
class SrcDstPair;
struct SrcDstPairDefaultTypeInternal;
extern SrcDstPairDefaultTypeInternal _SrcDstPair_default_instance_;
class Statistics;
struct StatisticsDefaultTypeInternal;
extern StatisticsDefaultTypeInternal _Statistics_default_instance_;
class VertexType;
struct VertexTypeDefaultTypeInternal;
extern VertexTypeDefaultTypeInternal _VertexType_default_instance_;
}  // namespace gie
PROTOBUF_NAMESPACE_OPEN
template<> ::gie::EdgeType* Arena::CreateMaybeMessage<::gie::EdgeType>(Arena*);
template<> ::gie::GraphPartitionStrategy* Arena::CreateMaybeMessage<::gie::GraphPartitionStrategy>(Arena*);
template<> ::gie::GraphPropertyPartitionStrategy* Arena::CreateMaybeMessage<::gie::GraphPropertyPartitionStrategy>(Arena*);
template<> ::gie::Property* Arena::CreateMaybeMessage<::gie::Property>(Arena*);
template<> ::gie::PropertyPartitionByEntityStrategy* Arena::CreateMaybeMessage<::gie::PropertyPartitionByEntityStrategy>(Arena*);
template<> ::gie::PropertyPartitionByTypeStrategy* Arena::CreateMaybeMessage<::gie::PropertyPartitionByTypeStrategy>(Arena*);
template<> ::gie::Schema* Arena::CreateMaybeMessage<::gie::Schema>(Arena*);
template<> ::gie::SrcDstPair* Arena::CreateMaybeMessage<::gie::SrcDstPair>(Arena*);
template<> ::gie::Statistics* Arena::CreateMaybeMessage<::gie::Statistics>(Arena*);
template<> ::gie::VertexType* Arena::CreateMaybeMessage<::gie::VertexType>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace gie {

enum VertexPartitionStrategy : int {
  VPS_UNDEFINED = 0,
  VPS_ALL = 1,
  VPS_ONE = 2,
  VPS_FOLLOW_EDGE = 3,
  VertexPartitionStrategy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VertexPartitionStrategy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VertexPartitionStrategy_IsValid(int value);
constexpr VertexPartitionStrategy VertexPartitionStrategy_MIN = VPS_UNDEFINED;
constexpr VertexPartitionStrategy VertexPartitionStrategy_MAX = VPS_FOLLOW_EDGE;
constexpr int VertexPartitionStrategy_ARRAYSIZE = VertexPartitionStrategy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VertexPartitionStrategy_descriptor();
template<typename T>
inline const std::string& VertexPartitionStrategy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VertexPartitionStrategy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VertexPartitionStrategy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VertexPartitionStrategy_descriptor(), enum_t_value);
}
inline bool VertexPartitionStrategy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VertexPartitionStrategy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VertexPartitionStrategy>(
    VertexPartitionStrategy_descriptor(), name, value);
}
enum EdgePartitionStrategy : int {
  EPS_UNDEFINED = 0,
  EPS_ALL = 1,
  EPS_ONE = 2,
  EPS_FOLLOW_SRC = 3,
  EPS_FOLLOW_DST = 4,
  EPS_FOLLOW_BOTH = 5,
  EdgePartitionStrategy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EdgePartitionStrategy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EdgePartitionStrategy_IsValid(int value);
constexpr EdgePartitionStrategy EdgePartitionStrategy_MIN = EPS_UNDEFINED;
constexpr EdgePartitionStrategy EdgePartitionStrategy_MAX = EPS_FOLLOW_BOTH;
constexpr int EdgePartitionStrategy_ARRAYSIZE = EdgePartitionStrategy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EdgePartitionStrategy_descriptor();
template<typename T>
inline const std::string& EdgePartitionStrategy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EdgePartitionStrategy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EdgePartitionStrategy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EdgePartitionStrategy_descriptor(), enum_t_value);
}
inline bool EdgePartitionStrategy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EdgePartitionStrategy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EdgePartitionStrategy>(
    EdgePartitionStrategy_descriptor(), name, value);
}
enum PropertyPartitionStrategy : int {
  PPS_UNDEFINED = 0,
  PPS_MASTER = 1,
  PPS_MASTER_MIRROR = 2,
  PropertyPartitionStrategy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PropertyPartitionStrategy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PropertyPartitionStrategy_IsValid(int value);
constexpr PropertyPartitionStrategy PropertyPartitionStrategy_MIN = PPS_UNDEFINED;
constexpr PropertyPartitionStrategy PropertyPartitionStrategy_MAX = PPS_MASTER_MIRROR;
constexpr int PropertyPartitionStrategy_ARRAYSIZE = PropertyPartitionStrategy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PropertyPartitionStrategy_descriptor();
template<typename T>
inline const std::string& PropertyPartitionStrategy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PropertyPartitionStrategy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PropertyPartitionStrategy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PropertyPartitionStrategy_descriptor(), enum_t_value);
}
inline bool PropertyPartitionStrategy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PropertyPartitionStrategy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PropertyPartitionStrategy>(
    PropertyPartitionStrategy_descriptor(), name, value);
}
enum GraphTopologyPartitionStrategy : int {
  GPS_UNDEFINED = 0,
  GPS_ALL_REPLICATE = 1,
  GPS_EDGE_CUT_FOLLOW_BOTH = 2,
  GPS_EDGE_CUT_FOLLOW_SRC = 3,
  GPS_EDGE_CUT_FOLLOW_DST = 4,
  GPS_VERTEX_CUT = 5,
  GPS_HYBRID = 6,
  GraphTopologyPartitionStrategy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GraphTopologyPartitionStrategy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GraphTopologyPartitionStrategy_IsValid(int value);
constexpr GraphTopologyPartitionStrategy GraphTopologyPartitionStrategy_MIN = GPS_UNDEFINED;
constexpr GraphTopologyPartitionStrategy GraphTopologyPartitionStrategy_MAX = GPS_HYBRID;
constexpr int GraphTopologyPartitionStrategy_ARRAYSIZE = GraphTopologyPartitionStrategy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GraphTopologyPartitionStrategy_descriptor();
template<typename T>
inline const std::string& GraphTopologyPartitionStrategy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GraphTopologyPartitionStrategy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GraphTopologyPartitionStrategy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GraphTopologyPartitionStrategy_descriptor(), enum_t_value);
}
inline bool GraphTopologyPartitionStrategy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GraphTopologyPartitionStrategy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GraphTopologyPartitionStrategy>(
    GraphTopologyPartitionStrategy_descriptor(), name, value);
}
enum Relation : int {
  REL_UNDEFINED = 0,
  MANY_TO_MANY = 1,
  MANY_TO_ONE = 2,
  ONE_TO_MANY = 3,
  ONE_TO_ONE = 4,
  Relation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Relation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Relation_IsValid(int value);
constexpr Relation Relation_MIN = REL_UNDEFINED;
constexpr Relation Relation_MAX = ONE_TO_ONE;
constexpr int Relation_ARRAYSIZE = Relation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Relation_descriptor();
template<typename T>
inline const std::string& Relation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Relation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Relation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Relation_descriptor(), enum_t_value);
}
inline bool Relation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Relation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Relation>(
    Relation_descriptor(), name, value);
}
enum DataType : int {
  DT_UNKNOWN = 0,
  DT_SIGNED_INT32 = 1,
  DT_UNSIGNED_INT32 = 2,
  DT_SIGNED_INT64 = 3,
  DT_UNSIGNED_INT64 = 4,
  DT_FLOAT = 5,
  DT_DOUBLE = 6,
  DT_STRING = 7,
  DT_DATE = 8,
  DT_TIME = 9,
  DT_TIMESTAMP = 10,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DataType_IsValid(int value);
constexpr DataType DataType_MIN = DT_UNKNOWN;
constexpr DataType DataType_MAX = DT_TIMESTAMP;
constexpr int DataType_ARRAYSIZE = DataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataType_descriptor();
template<typename T>
inline const std::string& DataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataType_descriptor(), enum_t_value);
}
inline bool DataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataType>(
    DataType_descriptor(), name, value);
}
// ===================================================================

class PropertyPartitionByEntityStrategy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gie.PropertyPartitionByEntityStrategy) */ {
 public:
  inline PropertyPartitionByEntityStrategy() : PropertyPartitionByEntityStrategy(nullptr) {}
  ~PropertyPartitionByEntityStrategy() override;
  explicit PROTOBUF_CONSTEXPR PropertyPartitionByEntityStrategy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PropertyPartitionByEntityStrategy(const PropertyPartitionByEntityStrategy& from);
  PropertyPartitionByEntityStrategy(PropertyPartitionByEntityStrategy&& from) noexcept
    : PropertyPartitionByEntityStrategy() {
    *this = ::std::move(from);
  }

  inline PropertyPartitionByEntityStrategy& operator=(const PropertyPartitionByEntityStrategy& from) {
    CopyFrom(from);
    return *this;
  }
  inline PropertyPartitionByEntityStrategy& operator=(PropertyPartitionByEntityStrategy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PropertyPartitionByEntityStrategy& default_instance() {
    return *internal_default_instance();
  }
  static inline const PropertyPartitionByEntityStrategy* internal_default_instance() {
    return reinterpret_cast<const PropertyPartitionByEntityStrategy*>(
               &_PropertyPartitionByEntityStrategy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PropertyPartitionByEntityStrategy& a, PropertyPartitionByEntityStrategy& b) {
    a.Swap(&b);
  }
  inline void Swap(PropertyPartitionByEntityStrategy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PropertyPartitionByEntityStrategy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PropertyPartitionByEntityStrategy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PropertyPartitionByEntityStrategy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PropertyPartitionByEntityStrategy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PropertyPartitionByEntityStrategy& from) {
    PropertyPartitionByEntityStrategy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PropertyPartitionByEntityStrategy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gie.PropertyPartitionByEntityStrategy";
  }
  protected:
  explicit PropertyPartitionByEntityStrategy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVertexPropertyPartitionStrategyFieldNumber = 1,
    kEdgePropertyPartitionStrategyFieldNumber = 2,
  };
  // .gie.PropertyPartitionStrategy vertex_property_partition_strategy = 1;
  void clear_vertex_property_partition_strategy();
  ::gie::PropertyPartitionStrategy vertex_property_partition_strategy() const;
  void set_vertex_property_partition_strategy(::gie::PropertyPartitionStrategy value);
  private:
  ::gie::PropertyPartitionStrategy _internal_vertex_property_partition_strategy() const;
  void _internal_set_vertex_property_partition_strategy(::gie::PropertyPartitionStrategy value);
  public:

  // .gie.PropertyPartitionStrategy edge_property_partition_strategy = 2;
  void clear_edge_property_partition_strategy();
  ::gie::PropertyPartitionStrategy edge_property_partition_strategy() const;
  void set_edge_property_partition_strategy(::gie::PropertyPartitionStrategy value);
  private:
  ::gie::PropertyPartitionStrategy _internal_edge_property_partition_strategy() const;
  void _internal_set_edge_property_partition_strategy(::gie::PropertyPartitionStrategy value);
  public:

  // @@protoc_insertion_point(class_scope:gie.PropertyPartitionByEntityStrategy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int vertex_property_partition_strategy_;
    int edge_property_partition_strategy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gie_5fschema_2eproto;
};
// -------------------------------------------------------------------

class PropertyPartitionByTypeStrategy final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:gie.PropertyPartitionByTypeStrategy) */ {
 public:
  inline PropertyPartitionByTypeStrategy() : PropertyPartitionByTypeStrategy(nullptr) {}
  explicit PROTOBUF_CONSTEXPR PropertyPartitionByTypeStrategy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PropertyPartitionByTypeStrategy(const PropertyPartitionByTypeStrategy& from);
  PropertyPartitionByTypeStrategy(PropertyPartitionByTypeStrategy&& from) noexcept
    : PropertyPartitionByTypeStrategy() {
    *this = ::std::move(from);
  }

  inline PropertyPartitionByTypeStrategy& operator=(const PropertyPartitionByTypeStrategy& from) {
    CopyFrom(from);
    return *this;
  }
  inline PropertyPartitionByTypeStrategy& operator=(PropertyPartitionByTypeStrategy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PropertyPartitionByTypeStrategy& default_instance() {
    return *internal_default_instance();
  }
  static inline const PropertyPartitionByTypeStrategy* internal_default_instance() {
    return reinterpret_cast<const PropertyPartitionByTypeStrategy*>(
               &_PropertyPartitionByTypeStrategy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PropertyPartitionByTypeStrategy& a, PropertyPartitionByTypeStrategy& b) {
    a.Swap(&b);
  }
  inline void Swap(PropertyPartitionByTypeStrategy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PropertyPartitionByTypeStrategy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PropertyPartitionByTypeStrategy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PropertyPartitionByTypeStrategy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PropertyPartitionByTypeStrategy& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PropertyPartitionByTypeStrategy& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gie.PropertyPartitionByTypeStrategy";
  }
  protected:
  explicit PropertyPartitionByTypeStrategy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:gie.PropertyPartitionByTypeStrategy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_gie_5fschema_2eproto;
};
// -------------------------------------------------------------------

class GraphPropertyPartitionStrategy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gie.GraphPropertyPartitionStrategy) */ {
 public:
  inline GraphPropertyPartitionStrategy() : GraphPropertyPartitionStrategy(nullptr) {}
  ~GraphPropertyPartitionStrategy() override;
  explicit PROTOBUF_CONSTEXPR GraphPropertyPartitionStrategy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GraphPropertyPartitionStrategy(const GraphPropertyPartitionStrategy& from);
  GraphPropertyPartitionStrategy(GraphPropertyPartitionStrategy&& from) noexcept
    : GraphPropertyPartitionStrategy() {
    *this = ::std::move(from);
  }

  inline GraphPropertyPartitionStrategy& operator=(const GraphPropertyPartitionStrategy& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphPropertyPartitionStrategy& operator=(GraphPropertyPartitionStrategy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GraphPropertyPartitionStrategy& default_instance() {
    return *internal_default_instance();
  }
  enum ItemCase {
    kByEntity = 1,
    kByType = 2,
    ITEM_NOT_SET = 0,
  };

  static inline const GraphPropertyPartitionStrategy* internal_default_instance() {
    return reinterpret_cast<const GraphPropertyPartitionStrategy*>(
               &_GraphPropertyPartitionStrategy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GraphPropertyPartitionStrategy& a, GraphPropertyPartitionStrategy& b) {
    a.Swap(&b);
  }
  inline void Swap(GraphPropertyPartitionStrategy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphPropertyPartitionStrategy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraphPropertyPartitionStrategy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GraphPropertyPartitionStrategy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GraphPropertyPartitionStrategy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GraphPropertyPartitionStrategy& from) {
    GraphPropertyPartitionStrategy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphPropertyPartitionStrategy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gie.GraphPropertyPartitionStrategy";
  }
  protected:
  explicit GraphPropertyPartitionStrategy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kByEntityFieldNumber = 1,
    kByTypeFieldNumber = 2,
  };
  // .gie.PropertyPartitionByEntityStrategy by_entity = 1;
  bool has_by_entity() const;
  private:
  bool _internal_has_by_entity() const;
  public:
  void clear_by_entity();
  const ::gie::PropertyPartitionByEntityStrategy& by_entity() const;
  PROTOBUF_NODISCARD ::gie::PropertyPartitionByEntityStrategy* release_by_entity();
  ::gie::PropertyPartitionByEntityStrategy* mutable_by_entity();
  void set_allocated_by_entity(::gie::PropertyPartitionByEntityStrategy* by_entity);
  private:
  const ::gie::PropertyPartitionByEntityStrategy& _internal_by_entity() const;
  ::gie::PropertyPartitionByEntityStrategy* _internal_mutable_by_entity();
  public:
  void unsafe_arena_set_allocated_by_entity(
      ::gie::PropertyPartitionByEntityStrategy* by_entity);
  ::gie::PropertyPartitionByEntityStrategy* unsafe_arena_release_by_entity();

  // .gie.PropertyPartitionByTypeStrategy by_type = 2;
  bool has_by_type() const;
  private:
  bool _internal_has_by_type() const;
  public:
  void clear_by_type();
  const ::gie::PropertyPartitionByTypeStrategy& by_type() const;
  PROTOBUF_NODISCARD ::gie::PropertyPartitionByTypeStrategy* release_by_type();
  ::gie::PropertyPartitionByTypeStrategy* mutable_by_type();
  void set_allocated_by_type(::gie::PropertyPartitionByTypeStrategy* by_type);
  private:
  const ::gie::PropertyPartitionByTypeStrategy& _internal_by_type() const;
  ::gie::PropertyPartitionByTypeStrategy* _internal_mutable_by_type();
  public:
  void unsafe_arena_set_allocated_by_type(
      ::gie::PropertyPartitionByTypeStrategy* by_type);
  ::gie::PropertyPartitionByTypeStrategy* unsafe_arena_release_by_type();

  void clear_item();
  ItemCase item_case() const;
  // @@protoc_insertion_point(class_scope:gie.GraphPropertyPartitionStrategy)
 private:
  class _Internal;
  void set_has_by_entity();
  void set_has_by_type();

  inline bool has_item() const;
  inline void clear_has_item();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ItemUnion {
      constexpr ItemUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::gie::PropertyPartitionByEntityStrategy* by_entity_;
      ::gie::PropertyPartitionByTypeStrategy* by_type_;
    } item_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gie_5fschema_2eproto;
};
// -------------------------------------------------------------------

class GraphPartitionStrategy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gie.GraphPartitionStrategy) */ {
 public:
  inline GraphPartitionStrategy() : GraphPartitionStrategy(nullptr) {}
  ~GraphPartitionStrategy() override;
  explicit PROTOBUF_CONSTEXPR GraphPartitionStrategy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GraphPartitionStrategy(const GraphPartitionStrategy& from);
  GraphPartitionStrategy(GraphPartitionStrategy&& from) noexcept
    : GraphPartitionStrategy() {
    *this = ::std::move(from);
  }

  inline GraphPartitionStrategy& operator=(const GraphPartitionStrategy& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphPartitionStrategy& operator=(GraphPartitionStrategy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GraphPartitionStrategy& default_instance() {
    return *internal_default_instance();
  }
  static inline const GraphPartitionStrategy* internal_default_instance() {
    return reinterpret_cast<const GraphPartitionStrategy*>(
               &_GraphPartitionStrategy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GraphPartitionStrategy& a, GraphPartitionStrategy& b) {
    a.Swap(&b);
  }
  inline void Swap(GraphPartitionStrategy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphPartitionStrategy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraphPartitionStrategy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GraphPartitionStrategy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GraphPartitionStrategy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GraphPartitionStrategy& from) {
    GraphPartitionStrategy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphPartitionStrategy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gie.GraphPartitionStrategy";
  }
  protected:
  explicit GraphPartitionStrategy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertyFieldNumber = 2,
    kTopologyFieldNumber = 1,
  };
  // .gie.GraphPropertyPartitionStrategy property = 2;
  bool has_property() const;
  private:
  bool _internal_has_property() const;
  public:
  void clear_property();
  const ::gie::GraphPropertyPartitionStrategy& property() const;
  PROTOBUF_NODISCARD ::gie::GraphPropertyPartitionStrategy* release_property();
  ::gie::GraphPropertyPartitionStrategy* mutable_property();
  void set_allocated_property(::gie::GraphPropertyPartitionStrategy* property);
  private:
  const ::gie::GraphPropertyPartitionStrategy& _internal_property() const;
  ::gie::GraphPropertyPartitionStrategy* _internal_mutable_property();
  public:
  void unsafe_arena_set_allocated_property(
      ::gie::GraphPropertyPartitionStrategy* property);
  ::gie::GraphPropertyPartitionStrategy* unsafe_arena_release_property();

  // .gie.GraphTopologyPartitionStrategy topology = 1;
  void clear_topology();
  ::gie::GraphTopologyPartitionStrategy topology() const;
  void set_topology(::gie::GraphTopologyPartitionStrategy value);
  private:
  ::gie::GraphTopologyPartitionStrategy _internal_topology() const;
  void _internal_set_topology(::gie::GraphTopologyPartitionStrategy value);
  public:

  // @@protoc_insertion_point(class_scope:gie.GraphPartitionStrategy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::gie::GraphPropertyPartitionStrategy* property_;
    int topology_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gie_5fschema_2eproto;
};
// -------------------------------------------------------------------

class SrcDstPair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gie.SrcDstPair) */ {
 public:
  inline SrcDstPair() : SrcDstPair(nullptr) {}
  ~SrcDstPair() override;
  explicit PROTOBUF_CONSTEXPR SrcDstPair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SrcDstPair(const SrcDstPair& from);
  SrcDstPair(SrcDstPair&& from) noexcept
    : SrcDstPair() {
    *this = ::std::move(from);
  }

  inline SrcDstPair& operator=(const SrcDstPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline SrcDstPair& operator=(SrcDstPair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SrcDstPair& default_instance() {
    return *internal_default_instance();
  }
  static inline const SrcDstPair* internal_default_instance() {
    return reinterpret_cast<const SrcDstPair*>(
               &_SrcDstPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SrcDstPair& a, SrcDstPair& b) {
    a.Swap(&b);
  }
  inline void Swap(SrcDstPair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SrcDstPair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SrcDstPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SrcDstPair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SrcDstPair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SrcDstPair& from) {
    SrcDstPair::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SrcDstPair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gie.SrcDstPair";
  }
  protected:
  explicit SrcDstPair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcTypeFieldNumber = 1,
    kDstTypeFieldNumber = 2,
    kPartitionStrategyFieldNumber = 3,
    kPropertyPartitionStrategyFieldNumber = 4,
    kRelationFieldNumber = 5,
  };
  // string src_type = 1;
  void clear_src_type();
  const std::string& src_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src_type();
  PROTOBUF_NODISCARD std::string* release_src_type();
  void set_allocated_src_type(std::string* src_type);
  private:
  const std::string& _internal_src_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_type(const std::string& value);
  std::string* _internal_mutable_src_type();
  public:

  // string dst_type = 2;
  void clear_dst_type();
  const std::string& dst_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dst_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dst_type();
  PROTOBUF_NODISCARD std::string* release_dst_type();
  void set_allocated_dst_type(std::string* dst_type);
  private:
  const std::string& _internal_dst_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst_type(const std::string& value);
  std::string* _internal_mutable_dst_type();
  public:

  // .gie.EdgePartitionStrategy partition_strategy = 3;
  void clear_partition_strategy();
  ::gie::EdgePartitionStrategy partition_strategy() const;
  void set_partition_strategy(::gie::EdgePartitionStrategy value);
  private:
  ::gie::EdgePartitionStrategy _internal_partition_strategy() const;
  void _internal_set_partition_strategy(::gie::EdgePartitionStrategy value);
  public:

  // .gie.PropertyPartitionStrategy property_partition_strategy = 4;
  void clear_property_partition_strategy();
  ::gie::PropertyPartitionStrategy property_partition_strategy() const;
  void set_property_partition_strategy(::gie::PropertyPartitionStrategy value);
  private:
  ::gie::PropertyPartitionStrategy _internal_property_partition_strategy() const;
  void _internal_set_property_partition_strategy(::gie::PropertyPartitionStrategy value);
  public:

  // .gie.Relation relation = 5;
  void clear_relation();
  ::gie::Relation relation() const;
  void set_relation(::gie::Relation value);
  private:
  ::gie::Relation _internal_relation() const;
  void _internal_set_relation(::gie::Relation value);
  public:

  // @@protoc_insertion_point(class_scope:gie.SrcDstPair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dst_type_;
    int partition_strategy_;
    int property_partition_strategy_;
    int relation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gie_5fschema_2eproto;
};
// -------------------------------------------------------------------

class Property final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gie.Property) */ {
 public:
  inline Property() : Property(nullptr) {}
  ~Property() override;
  explicit PROTOBUF_CONSTEXPR Property(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Property(const Property& from);
  Property(Property&& from) noexcept
    : Property() {
    *this = ::std::move(from);
  }

  inline Property& operator=(const Property& from) {
    CopyFrom(from);
    return *this;
  }
  inline Property& operator=(Property&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Property& default_instance() {
    return *internal_default_instance();
  }
  static inline const Property* internal_default_instance() {
    return reinterpret_cast<const Property*>(
               &_Property_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Property& a, Property& b) {
    a.Swap(&b);
  }
  inline void Swap(Property* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Property* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Property* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Property>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Property& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Property& from) {
    Property::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Property* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gie.Property";
  }
  protected:
  explicit Property(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 3,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // .gie.DataType type = 3;
  void clear_type();
  ::gie::DataType type() const;
  void set_type(::gie::DataType value);
  private:
  ::gie::DataType _internal_type() const;
  void _internal_set_type(::gie::DataType value);
  public:

  // @@protoc_insertion_point(class_scope:gie.Property)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint32_t id_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gie_5fschema_2eproto;
};
// -------------------------------------------------------------------

class VertexType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gie.VertexType) */ {
 public:
  inline VertexType() : VertexType(nullptr) {}
  ~VertexType() override;
  explicit PROTOBUF_CONSTEXPR VertexType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VertexType(const VertexType& from);
  VertexType(VertexType&& from) noexcept
    : VertexType() {
    *this = ::std::move(from);
  }

  inline VertexType& operator=(const VertexType& from) {
    CopyFrom(from);
    return *this;
  }
  inline VertexType& operator=(VertexType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VertexType& default_instance() {
    return *internal_default_instance();
  }
  static inline const VertexType* internal_default_instance() {
    return reinterpret_cast<const VertexType*>(
               &_VertexType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(VertexType& a, VertexType& b) {
    a.Swap(&b);
  }
  inline void Swap(VertexType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VertexType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VertexType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VertexType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VertexType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VertexType& from) {
    VertexType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VertexType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gie.VertexType";
  }
  protected:
  explicit VertexType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 3,
    kPrimaryKeysFieldNumber = 4,
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
    kPartitionStrategyFieldNumber = 5,
    kTotalNumFieldNumber = 7,
    kPropertyPartitionStrategyFieldNumber = 6,
  };
  // repeated .gie.Property properties = 3;
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  ::gie::Property* mutable_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gie::Property >*
      mutable_properties();
  private:
  const ::gie::Property& _internal_properties(int index) const;
  ::gie::Property* _internal_add_properties();
  public:
  const ::gie::Property& properties(int index) const;
  ::gie::Property* add_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gie::Property >&
      properties() const;

  // repeated string primary_keys = 4;
  int primary_keys_size() const;
  private:
  int _internal_primary_keys_size() const;
  public:
  void clear_primary_keys();
  const std::string& primary_keys(int index) const;
  std::string* mutable_primary_keys(int index);
  void set_primary_keys(int index, const std::string& value);
  void set_primary_keys(int index, std::string&& value);
  void set_primary_keys(int index, const char* value);
  void set_primary_keys(int index, const char* value, size_t size);
  std::string* add_primary_keys();
  void add_primary_keys(const std::string& value);
  void add_primary_keys(std::string&& value);
  void add_primary_keys(const char* value);
  void add_primary_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& primary_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_primary_keys();
  private:
  const std::string& _internal_primary_keys(int index) const;
  std::string* _internal_add_primary_keys();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // .gie.VertexPartitionStrategy partition_strategy = 5;
  void clear_partition_strategy();
  ::gie::VertexPartitionStrategy partition_strategy() const;
  void set_partition_strategy(::gie::VertexPartitionStrategy value);
  private:
  ::gie::VertexPartitionStrategy _internal_partition_strategy() const;
  void _internal_set_partition_strategy(::gie::VertexPartitionStrategy value);
  public:

  // int64 total_num = 7;
  void clear_total_num();
  int64_t total_num() const;
  void set_total_num(int64_t value);
  private:
  int64_t _internal_total_num() const;
  void _internal_set_total_num(int64_t value);
  public:

  // .gie.PropertyPartitionStrategy property_partition_strategy = 6;
  void clear_property_partition_strategy();
  ::gie::PropertyPartitionStrategy property_partition_strategy() const;
  void set_property_partition_strategy(::gie::PropertyPartitionStrategy value);
  private:
  ::gie::PropertyPartitionStrategy _internal_property_partition_strategy() const;
  void _internal_set_property_partition_strategy(::gie::PropertyPartitionStrategy value);
  public:

  // @@protoc_insertion_point(class_scope:gie.VertexType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gie::Property > properties_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> primary_keys_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint32_t id_;
    int partition_strategy_;
    int64_t total_num_;
    int property_partition_strategy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gie_5fschema_2eproto;
};
// -------------------------------------------------------------------

class EdgeType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gie.EdgeType) */ {
 public:
  inline EdgeType() : EdgeType(nullptr) {}
  ~EdgeType() override;
  explicit PROTOBUF_CONSTEXPR EdgeType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EdgeType(const EdgeType& from);
  EdgeType(EdgeType&& from) noexcept
    : EdgeType() {
    *this = ::std::move(from);
  }

  inline EdgeType& operator=(const EdgeType& from) {
    CopyFrom(from);
    return *this;
  }
  inline EdgeType& operator=(EdgeType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EdgeType& default_instance() {
    return *internal_default_instance();
  }
  static inline const EdgeType* internal_default_instance() {
    return reinterpret_cast<const EdgeType*>(
               &_EdgeType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(EdgeType& a, EdgeType& b) {
    a.Swap(&b);
  }
  inline void Swap(EdgeType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EdgeType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EdgeType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EdgeType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EdgeType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EdgeType& from) {
    EdgeType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EdgeType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gie.EdgeType";
  }
  protected:
  explicit EdgeType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 3,
    kPrimaryKeysFieldNumber = 4,
    kSrcDstPairsFieldNumber = 5,
    kNameFieldNumber = 2,
    kTotalNumFieldNumber = 6,
    kIdFieldNumber = 1,
  };
  // repeated .gie.Property properties = 3;
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  ::gie::Property* mutable_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gie::Property >*
      mutable_properties();
  private:
  const ::gie::Property& _internal_properties(int index) const;
  ::gie::Property* _internal_add_properties();
  public:
  const ::gie::Property& properties(int index) const;
  ::gie::Property* add_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gie::Property >&
      properties() const;

  // repeated string primary_keys = 4;
  int primary_keys_size() const;
  private:
  int _internal_primary_keys_size() const;
  public:
  void clear_primary_keys();
  const std::string& primary_keys(int index) const;
  std::string* mutable_primary_keys(int index);
  void set_primary_keys(int index, const std::string& value);
  void set_primary_keys(int index, std::string&& value);
  void set_primary_keys(int index, const char* value);
  void set_primary_keys(int index, const char* value, size_t size);
  std::string* add_primary_keys();
  void add_primary_keys(const std::string& value);
  void add_primary_keys(std::string&& value);
  void add_primary_keys(const char* value);
  void add_primary_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& primary_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_primary_keys();
  private:
  const std::string& _internal_primary_keys(int index) const;
  std::string* _internal_add_primary_keys();
  public:

  // repeated .gie.SrcDstPair src_dst_pairs = 5;
  int src_dst_pairs_size() const;
  private:
  int _internal_src_dst_pairs_size() const;
  public:
  void clear_src_dst_pairs();
  ::gie::SrcDstPair* mutable_src_dst_pairs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gie::SrcDstPair >*
      mutable_src_dst_pairs();
  private:
  const ::gie::SrcDstPair& _internal_src_dst_pairs(int index) const;
  ::gie::SrcDstPair* _internal_add_src_dst_pairs();
  public:
  const ::gie::SrcDstPair& src_dst_pairs(int index) const;
  ::gie::SrcDstPair* add_src_dst_pairs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gie::SrcDstPair >&
      src_dst_pairs() const;

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int64 total_num = 6;
  void clear_total_num();
  int64_t total_num() const;
  void set_total_num(int64_t value);
  private:
  int64_t _internal_total_num() const;
  void _internal_set_total_num(int64_t value);
  public:

  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:gie.EdgeType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gie::Property > properties_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> primary_keys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gie::SrcDstPair > src_dst_pairs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int64_t total_num_;
    uint32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gie_5fschema_2eproto;
};
// -------------------------------------------------------------------

class Statistics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gie.Statistics) */ {
 public:
  inline Statistics() : Statistics(nullptr) {}
  ~Statistics() override;
  explicit PROTOBUF_CONSTEXPR Statistics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Statistics(const Statistics& from);
  Statistics(Statistics&& from) noexcept
    : Statistics() {
    *this = ::std::move(from);
  }

  inline Statistics& operator=(const Statistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline Statistics& operator=(Statistics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Statistics& default_instance() {
    return *internal_default_instance();
  }
  static inline const Statistics* internal_default_instance() {
    return reinterpret_cast<const Statistics*>(
               &_Statistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Statistics& a, Statistics& b) {
    a.Swap(&b);
  }
  inline void Swap(Statistics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Statistics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Statistics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Statistics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Statistics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Statistics& from) {
    Statistics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Statistics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gie.Statistics";
  }
  protected:
  explicit Statistics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumVerticesFieldNumber = 2,
    kNumEdgesFieldNumber = 3,
    kNumPartitionsFieldNumber = 1,
  };
  // uint64 num_vertices = 2;
  void clear_num_vertices();
  uint64_t num_vertices() const;
  void set_num_vertices(uint64_t value);
  private:
  uint64_t _internal_num_vertices() const;
  void _internal_set_num_vertices(uint64_t value);
  public:

  // uint64 num_edges = 3;
  void clear_num_edges();
  uint64_t num_edges() const;
  void set_num_edges(uint64_t value);
  private:
  uint64_t _internal_num_edges() const;
  void _internal_set_num_edges(uint64_t value);
  public:

  // uint32 num_partitions = 1;
  void clear_num_partitions();
  uint32_t num_partitions() const;
  void set_num_partitions(uint32_t value);
  private:
  uint32_t _internal_num_partitions() const;
  void _internal_set_num_partitions(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:gie.Statistics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t num_vertices_;
    uint64_t num_edges_;
    uint32_t num_partitions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gie_5fschema_2eproto;
};
// -------------------------------------------------------------------

class Schema final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gie.Schema) */ {
 public:
  inline Schema() : Schema(nullptr) {}
  ~Schema() override;
  explicit PROTOBUF_CONSTEXPR Schema(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Schema(const Schema& from);
  Schema(Schema&& from) noexcept
    : Schema() {
    *this = ::std::move(from);
  }

  inline Schema& operator=(const Schema& from) {
    CopyFrom(from);
    return *this;
  }
  inline Schema& operator=(Schema&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Schema& default_instance() {
    return *internal_default_instance();
  }
  static inline const Schema* internal_default_instance() {
    return reinterpret_cast<const Schema*>(
               &_Schema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Schema& a, Schema& b) {
    a.Swap(&b);
  }
  inline void Swap(Schema* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Schema* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Schema* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Schema>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Schema& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Schema& from) {
    Schema::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Schema* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gie.Schema";
  }
  protected:
  explicit Schema(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVertexTypesFieldNumber = 2,
    kEdgeTypesFieldNumber = 3,
    kPartitionStrategyFieldNumber = 1,
    kStatisticsFieldNumber = 4,
  };
  // repeated .gie.VertexType vertex_types = 2;
  int vertex_types_size() const;
  private:
  int _internal_vertex_types_size() const;
  public:
  void clear_vertex_types();
  ::gie::VertexType* mutable_vertex_types(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gie::VertexType >*
      mutable_vertex_types();
  private:
  const ::gie::VertexType& _internal_vertex_types(int index) const;
  ::gie::VertexType* _internal_add_vertex_types();
  public:
  const ::gie::VertexType& vertex_types(int index) const;
  ::gie::VertexType* add_vertex_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gie::VertexType >&
      vertex_types() const;

  // repeated .gie.EdgeType edge_types = 3;
  int edge_types_size() const;
  private:
  int _internal_edge_types_size() const;
  public:
  void clear_edge_types();
  ::gie::EdgeType* mutable_edge_types(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gie::EdgeType >*
      mutable_edge_types();
  private:
  const ::gie::EdgeType& _internal_edge_types(int index) const;
  ::gie::EdgeType* _internal_add_edge_types();
  public:
  const ::gie::EdgeType& edge_types(int index) const;
  ::gie::EdgeType* add_edge_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gie::EdgeType >&
      edge_types() const;

  // .gie.GraphPartitionStrategy partition_strategy = 1;
  bool has_partition_strategy() const;
  private:
  bool _internal_has_partition_strategy() const;
  public:
  void clear_partition_strategy();
  const ::gie::GraphPartitionStrategy& partition_strategy() const;
  PROTOBUF_NODISCARD ::gie::GraphPartitionStrategy* release_partition_strategy();
  ::gie::GraphPartitionStrategy* mutable_partition_strategy();
  void set_allocated_partition_strategy(::gie::GraphPartitionStrategy* partition_strategy);
  private:
  const ::gie::GraphPartitionStrategy& _internal_partition_strategy() const;
  ::gie::GraphPartitionStrategy* _internal_mutable_partition_strategy();
  public:
  void unsafe_arena_set_allocated_partition_strategy(
      ::gie::GraphPartitionStrategy* partition_strategy);
  ::gie::GraphPartitionStrategy* unsafe_arena_release_partition_strategy();

  // .gie.Statistics statistics = 4;
  bool has_statistics() const;
  private:
  bool _internal_has_statistics() const;
  public:
  void clear_statistics();
  const ::gie::Statistics& statistics() const;
  PROTOBUF_NODISCARD ::gie::Statistics* release_statistics();
  ::gie::Statistics* mutable_statistics();
  void set_allocated_statistics(::gie::Statistics* statistics);
  private:
  const ::gie::Statistics& _internal_statistics() const;
  ::gie::Statistics* _internal_mutable_statistics();
  public:
  void unsafe_arena_set_allocated_statistics(
      ::gie::Statistics* statistics);
  ::gie::Statistics* unsafe_arena_release_statistics();

  // @@protoc_insertion_point(class_scope:gie.Schema)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gie::VertexType > vertex_types_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gie::EdgeType > edge_types_;
    ::gie::GraphPartitionStrategy* partition_strategy_;
    ::gie::Statistics* statistics_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gie_5fschema_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PropertyPartitionByEntityStrategy

// .gie.PropertyPartitionStrategy vertex_property_partition_strategy = 1;
inline void PropertyPartitionByEntityStrategy::clear_vertex_property_partition_strategy() {
  _impl_.vertex_property_partition_strategy_ = 0;
}
inline ::gie::PropertyPartitionStrategy PropertyPartitionByEntityStrategy::_internal_vertex_property_partition_strategy() const {
  return static_cast< ::gie::PropertyPartitionStrategy >(_impl_.vertex_property_partition_strategy_);
}
inline ::gie::PropertyPartitionStrategy PropertyPartitionByEntityStrategy::vertex_property_partition_strategy() const {
  // @@protoc_insertion_point(field_get:gie.PropertyPartitionByEntityStrategy.vertex_property_partition_strategy)
  return _internal_vertex_property_partition_strategy();
}
inline void PropertyPartitionByEntityStrategy::_internal_set_vertex_property_partition_strategy(::gie::PropertyPartitionStrategy value) {
  
  _impl_.vertex_property_partition_strategy_ = value;
}
inline void PropertyPartitionByEntityStrategy::set_vertex_property_partition_strategy(::gie::PropertyPartitionStrategy value) {
  _internal_set_vertex_property_partition_strategy(value);
  // @@protoc_insertion_point(field_set:gie.PropertyPartitionByEntityStrategy.vertex_property_partition_strategy)
}

// .gie.PropertyPartitionStrategy edge_property_partition_strategy = 2;
inline void PropertyPartitionByEntityStrategy::clear_edge_property_partition_strategy() {
  _impl_.edge_property_partition_strategy_ = 0;
}
inline ::gie::PropertyPartitionStrategy PropertyPartitionByEntityStrategy::_internal_edge_property_partition_strategy() const {
  return static_cast< ::gie::PropertyPartitionStrategy >(_impl_.edge_property_partition_strategy_);
}
inline ::gie::PropertyPartitionStrategy PropertyPartitionByEntityStrategy::edge_property_partition_strategy() const {
  // @@protoc_insertion_point(field_get:gie.PropertyPartitionByEntityStrategy.edge_property_partition_strategy)
  return _internal_edge_property_partition_strategy();
}
inline void PropertyPartitionByEntityStrategy::_internal_set_edge_property_partition_strategy(::gie::PropertyPartitionStrategy value) {
  
  _impl_.edge_property_partition_strategy_ = value;
}
inline void PropertyPartitionByEntityStrategy::set_edge_property_partition_strategy(::gie::PropertyPartitionStrategy value) {
  _internal_set_edge_property_partition_strategy(value);
  // @@protoc_insertion_point(field_set:gie.PropertyPartitionByEntityStrategy.edge_property_partition_strategy)
}

// -------------------------------------------------------------------

// PropertyPartitionByTypeStrategy

// -------------------------------------------------------------------

// GraphPropertyPartitionStrategy

// .gie.PropertyPartitionByEntityStrategy by_entity = 1;
inline bool GraphPropertyPartitionStrategy::_internal_has_by_entity() const {
  return item_case() == kByEntity;
}
inline bool GraphPropertyPartitionStrategy::has_by_entity() const {
  return _internal_has_by_entity();
}
inline void GraphPropertyPartitionStrategy::set_has_by_entity() {
  _impl_._oneof_case_[0] = kByEntity;
}
inline void GraphPropertyPartitionStrategy::clear_by_entity() {
  if (_internal_has_by_entity()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.item_.by_entity_;
    }
    clear_has_item();
  }
}
inline ::gie::PropertyPartitionByEntityStrategy* GraphPropertyPartitionStrategy::release_by_entity() {
  // @@protoc_insertion_point(field_release:gie.GraphPropertyPartitionStrategy.by_entity)
  if (_internal_has_by_entity()) {
    clear_has_item();
    ::gie::PropertyPartitionByEntityStrategy* temp = _impl_.item_.by_entity_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.item_.by_entity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gie::PropertyPartitionByEntityStrategy& GraphPropertyPartitionStrategy::_internal_by_entity() const {
  return _internal_has_by_entity()
      ? *_impl_.item_.by_entity_
      : reinterpret_cast< ::gie::PropertyPartitionByEntityStrategy&>(::gie::_PropertyPartitionByEntityStrategy_default_instance_);
}
inline const ::gie::PropertyPartitionByEntityStrategy& GraphPropertyPartitionStrategy::by_entity() const {
  // @@protoc_insertion_point(field_get:gie.GraphPropertyPartitionStrategy.by_entity)
  return _internal_by_entity();
}
inline ::gie::PropertyPartitionByEntityStrategy* GraphPropertyPartitionStrategy::unsafe_arena_release_by_entity() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gie.GraphPropertyPartitionStrategy.by_entity)
  if (_internal_has_by_entity()) {
    clear_has_item();
    ::gie::PropertyPartitionByEntityStrategy* temp = _impl_.item_.by_entity_;
    _impl_.item_.by_entity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GraphPropertyPartitionStrategy::unsafe_arena_set_allocated_by_entity(::gie::PropertyPartitionByEntityStrategy* by_entity) {
  clear_item();
  if (by_entity) {
    set_has_by_entity();
    _impl_.item_.by_entity_ = by_entity;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gie.GraphPropertyPartitionStrategy.by_entity)
}
inline ::gie::PropertyPartitionByEntityStrategy* GraphPropertyPartitionStrategy::_internal_mutable_by_entity() {
  if (!_internal_has_by_entity()) {
    clear_item();
    set_has_by_entity();
    _impl_.item_.by_entity_ = CreateMaybeMessage< ::gie::PropertyPartitionByEntityStrategy >(GetArenaForAllocation());
  }
  return _impl_.item_.by_entity_;
}
inline ::gie::PropertyPartitionByEntityStrategy* GraphPropertyPartitionStrategy::mutable_by_entity() {
  ::gie::PropertyPartitionByEntityStrategy* _msg = _internal_mutable_by_entity();
  // @@protoc_insertion_point(field_mutable:gie.GraphPropertyPartitionStrategy.by_entity)
  return _msg;
}

// .gie.PropertyPartitionByTypeStrategy by_type = 2;
inline bool GraphPropertyPartitionStrategy::_internal_has_by_type() const {
  return item_case() == kByType;
}
inline bool GraphPropertyPartitionStrategy::has_by_type() const {
  return _internal_has_by_type();
}
inline void GraphPropertyPartitionStrategy::set_has_by_type() {
  _impl_._oneof_case_[0] = kByType;
}
inline void GraphPropertyPartitionStrategy::clear_by_type() {
  if (_internal_has_by_type()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.item_.by_type_;
    }
    clear_has_item();
  }
}
inline ::gie::PropertyPartitionByTypeStrategy* GraphPropertyPartitionStrategy::release_by_type() {
  // @@protoc_insertion_point(field_release:gie.GraphPropertyPartitionStrategy.by_type)
  if (_internal_has_by_type()) {
    clear_has_item();
    ::gie::PropertyPartitionByTypeStrategy* temp = _impl_.item_.by_type_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.item_.by_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gie::PropertyPartitionByTypeStrategy& GraphPropertyPartitionStrategy::_internal_by_type() const {
  return _internal_has_by_type()
      ? *_impl_.item_.by_type_
      : reinterpret_cast< ::gie::PropertyPartitionByTypeStrategy&>(::gie::_PropertyPartitionByTypeStrategy_default_instance_);
}
inline const ::gie::PropertyPartitionByTypeStrategy& GraphPropertyPartitionStrategy::by_type() const {
  // @@protoc_insertion_point(field_get:gie.GraphPropertyPartitionStrategy.by_type)
  return _internal_by_type();
}
inline ::gie::PropertyPartitionByTypeStrategy* GraphPropertyPartitionStrategy::unsafe_arena_release_by_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gie.GraphPropertyPartitionStrategy.by_type)
  if (_internal_has_by_type()) {
    clear_has_item();
    ::gie::PropertyPartitionByTypeStrategy* temp = _impl_.item_.by_type_;
    _impl_.item_.by_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GraphPropertyPartitionStrategy::unsafe_arena_set_allocated_by_type(::gie::PropertyPartitionByTypeStrategy* by_type) {
  clear_item();
  if (by_type) {
    set_has_by_type();
    _impl_.item_.by_type_ = by_type;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gie.GraphPropertyPartitionStrategy.by_type)
}
inline ::gie::PropertyPartitionByTypeStrategy* GraphPropertyPartitionStrategy::_internal_mutable_by_type() {
  if (!_internal_has_by_type()) {
    clear_item();
    set_has_by_type();
    _impl_.item_.by_type_ = CreateMaybeMessage< ::gie::PropertyPartitionByTypeStrategy >(GetArenaForAllocation());
  }
  return _impl_.item_.by_type_;
}
inline ::gie::PropertyPartitionByTypeStrategy* GraphPropertyPartitionStrategy::mutable_by_type() {
  ::gie::PropertyPartitionByTypeStrategy* _msg = _internal_mutable_by_type();
  // @@protoc_insertion_point(field_mutable:gie.GraphPropertyPartitionStrategy.by_type)
  return _msg;
}

inline bool GraphPropertyPartitionStrategy::has_item() const {
  return item_case() != ITEM_NOT_SET;
}
inline void GraphPropertyPartitionStrategy::clear_has_item() {
  _impl_._oneof_case_[0] = ITEM_NOT_SET;
}
inline GraphPropertyPartitionStrategy::ItemCase GraphPropertyPartitionStrategy::item_case() const {
  return GraphPropertyPartitionStrategy::ItemCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GraphPartitionStrategy

// .gie.GraphTopologyPartitionStrategy topology = 1;
inline void GraphPartitionStrategy::clear_topology() {
  _impl_.topology_ = 0;
}
inline ::gie::GraphTopologyPartitionStrategy GraphPartitionStrategy::_internal_topology() const {
  return static_cast< ::gie::GraphTopologyPartitionStrategy >(_impl_.topology_);
}
inline ::gie::GraphTopologyPartitionStrategy GraphPartitionStrategy::topology() const {
  // @@protoc_insertion_point(field_get:gie.GraphPartitionStrategy.topology)
  return _internal_topology();
}
inline void GraphPartitionStrategy::_internal_set_topology(::gie::GraphTopologyPartitionStrategy value) {
  
  _impl_.topology_ = value;
}
inline void GraphPartitionStrategy::set_topology(::gie::GraphTopologyPartitionStrategy value) {
  _internal_set_topology(value);
  // @@protoc_insertion_point(field_set:gie.GraphPartitionStrategy.topology)
}

// .gie.GraphPropertyPartitionStrategy property = 2;
inline bool GraphPartitionStrategy::_internal_has_property() const {
  return this != internal_default_instance() && _impl_.property_ != nullptr;
}
inline bool GraphPartitionStrategy::has_property() const {
  return _internal_has_property();
}
inline void GraphPartitionStrategy::clear_property() {
  if (GetArenaForAllocation() == nullptr && _impl_.property_ != nullptr) {
    delete _impl_.property_;
  }
  _impl_.property_ = nullptr;
}
inline const ::gie::GraphPropertyPartitionStrategy& GraphPartitionStrategy::_internal_property() const {
  const ::gie::GraphPropertyPartitionStrategy* p = _impl_.property_;
  return p != nullptr ? *p : reinterpret_cast<const ::gie::GraphPropertyPartitionStrategy&>(
      ::gie::_GraphPropertyPartitionStrategy_default_instance_);
}
inline const ::gie::GraphPropertyPartitionStrategy& GraphPartitionStrategy::property() const {
  // @@protoc_insertion_point(field_get:gie.GraphPartitionStrategy.property)
  return _internal_property();
}
inline void GraphPartitionStrategy::unsafe_arena_set_allocated_property(
    ::gie::GraphPropertyPartitionStrategy* property) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.property_);
  }
  _impl_.property_ = property;
  if (property) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gie.GraphPartitionStrategy.property)
}
inline ::gie::GraphPropertyPartitionStrategy* GraphPartitionStrategy::release_property() {
  
  ::gie::GraphPropertyPartitionStrategy* temp = _impl_.property_;
  _impl_.property_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gie::GraphPropertyPartitionStrategy* GraphPartitionStrategy::unsafe_arena_release_property() {
  // @@protoc_insertion_point(field_release:gie.GraphPartitionStrategy.property)
  
  ::gie::GraphPropertyPartitionStrategy* temp = _impl_.property_;
  _impl_.property_ = nullptr;
  return temp;
}
inline ::gie::GraphPropertyPartitionStrategy* GraphPartitionStrategy::_internal_mutable_property() {
  
  if (_impl_.property_ == nullptr) {
    auto* p = CreateMaybeMessage<::gie::GraphPropertyPartitionStrategy>(GetArenaForAllocation());
    _impl_.property_ = p;
  }
  return _impl_.property_;
}
inline ::gie::GraphPropertyPartitionStrategy* GraphPartitionStrategy::mutable_property() {
  ::gie::GraphPropertyPartitionStrategy* _msg = _internal_mutable_property();
  // @@protoc_insertion_point(field_mutable:gie.GraphPartitionStrategy.property)
  return _msg;
}
inline void GraphPartitionStrategy::set_allocated_property(::gie::GraphPropertyPartitionStrategy* property) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.property_;
  }
  if (property) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(property);
    if (message_arena != submessage_arena) {
      property = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, property, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.property_ = property;
  // @@protoc_insertion_point(field_set_allocated:gie.GraphPartitionStrategy.property)
}

// -------------------------------------------------------------------

// SrcDstPair

// string src_type = 1;
inline void SrcDstPair::clear_src_type() {
  _impl_.src_type_.ClearToEmpty();
}
inline const std::string& SrcDstPair::src_type() const {
  // @@protoc_insertion_point(field_get:gie.SrcDstPair.src_type)
  return _internal_src_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SrcDstPair::set_src_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gie.SrcDstPair.src_type)
}
inline std::string* SrcDstPair::mutable_src_type() {
  std::string* _s = _internal_mutable_src_type();
  // @@protoc_insertion_point(field_mutable:gie.SrcDstPair.src_type)
  return _s;
}
inline const std::string& SrcDstPair::_internal_src_type() const {
  return _impl_.src_type_.Get();
}
inline void SrcDstPair::_internal_set_src_type(const std::string& value) {
  
  _impl_.src_type_.Set(value, GetArenaForAllocation());
}
inline std::string* SrcDstPair::_internal_mutable_src_type() {
  
  return _impl_.src_type_.Mutable(GetArenaForAllocation());
}
inline std::string* SrcDstPair::release_src_type() {
  // @@protoc_insertion_point(field_release:gie.SrcDstPair.src_type)
  return _impl_.src_type_.Release();
}
inline void SrcDstPair::set_allocated_src_type(std::string* src_type) {
  if (src_type != nullptr) {
    
  } else {
    
  }
  _impl_.src_type_.SetAllocated(src_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_type_.IsDefault()) {
    _impl_.src_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gie.SrcDstPair.src_type)
}

// string dst_type = 2;
inline void SrcDstPair::clear_dst_type() {
  _impl_.dst_type_.ClearToEmpty();
}
inline const std::string& SrcDstPair::dst_type() const {
  // @@protoc_insertion_point(field_get:gie.SrcDstPair.dst_type)
  return _internal_dst_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SrcDstPair::set_dst_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dst_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gie.SrcDstPair.dst_type)
}
inline std::string* SrcDstPair::mutable_dst_type() {
  std::string* _s = _internal_mutable_dst_type();
  // @@protoc_insertion_point(field_mutable:gie.SrcDstPair.dst_type)
  return _s;
}
inline const std::string& SrcDstPair::_internal_dst_type() const {
  return _impl_.dst_type_.Get();
}
inline void SrcDstPair::_internal_set_dst_type(const std::string& value) {
  
  _impl_.dst_type_.Set(value, GetArenaForAllocation());
}
inline std::string* SrcDstPair::_internal_mutable_dst_type() {
  
  return _impl_.dst_type_.Mutable(GetArenaForAllocation());
}
inline std::string* SrcDstPair::release_dst_type() {
  // @@protoc_insertion_point(field_release:gie.SrcDstPair.dst_type)
  return _impl_.dst_type_.Release();
}
inline void SrcDstPair::set_allocated_dst_type(std::string* dst_type) {
  if (dst_type != nullptr) {
    
  } else {
    
  }
  _impl_.dst_type_.SetAllocated(dst_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dst_type_.IsDefault()) {
    _impl_.dst_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gie.SrcDstPair.dst_type)
}

// .gie.EdgePartitionStrategy partition_strategy = 3;
inline void SrcDstPair::clear_partition_strategy() {
  _impl_.partition_strategy_ = 0;
}
inline ::gie::EdgePartitionStrategy SrcDstPair::_internal_partition_strategy() const {
  return static_cast< ::gie::EdgePartitionStrategy >(_impl_.partition_strategy_);
}
inline ::gie::EdgePartitionStrategy SrcDstPair::partition_strategy() const {
  // @@protoc_insertion_point(field_get:gie.SrcDstPair.partition_strategy)
  return _internal_partition_strategy();
}
inline void SrcDstPair::_internal_set_partition_strategy(::gie::EdgePartitionStrategy value) {
  
  _impl_.partition_strategy_ = value;
}
inline void SrcDstPair::set_partition_strategy(::gie::EdgePartitionStrategy value) {
  _internal_set_partition_strategy(value);
  // @@protoc_insertion_point(field_set:gie.SrcDstPair.partition_strategy)
}

// .gie.PropertyPartitionStrategy property_partition_strategy = 4;
inline void SrcDstPair::clear_property_partition_strategy() {
  _impl_.property_partition_strategy_ = 0;
}
inline ::gie::PropertyPartitionStrategy SrcDstPair::_internal_property_partition_strategy() const {
  return static_cast< ::gie::PropertyPartitionStrategy >(_impl_.property_partition_strategy_);
}
inline ::gie::PropertyPartitionStrategy SrcDstPair::property_partition_strategy() const {
  // @@protoc_insertion_point(field_get:gie.SrcDstPair.property_partition_strategy)
  return _internal_property_partition_strategy();
}
inline void SrcDstPair::_internal_set_property_partition_strategy(::gie::PropertyPartitionStrategy value) {
  
  _impl_.property_partition_strategy_ = value;
}
inline void SrcDstPair::set_property_partition_strategy(::gie::PropertyPartitionStrategy value) {
  _internal_set_property_partition_strategy(value);
  // @@protoc_insertion_point(field_set:gie.SrcDstPair.property_partition_strategy)
}

// .gie.Relation relation = 5;
inline void SrcDstPair::clear_relation() {
  _impl_.relation_ = 0;
}
inline ::gie::Relation SrcDstPair::_internal_relation() const {
  return static_cast< ::gie::Relation >(_impl_.relation_);
}
inline ::gie::Relation SrcDstPair::relation() const {
  // @@protoc_insertion_point(field_get:gie.SrcDstPair.relation)
  return _internal_relation();
}
inline void SrcDstPair::_internal_set_relation(::gie::Relation value) {
  
  _impl_.relation_ = value;
}
inline void SrcDstPair::set_relation(::gie::Relation value) {
  _internal_set_relation(value);
  // @@protoc_insertion_point(field_set:gie.SrcDstPair.relation)
}

// -------------------------------------------------------------------

// Property

// uint32 id = 1;
inline void Property::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t Property::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t Property::id() const {
  // @@protoc_insertion_point(field_get:gie.Property.id)
  return _internal_id();
}
inline void Property::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void Property::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:gie.Property.id)
}

// string name = 2;
inline void Property::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Property::name() const {
  // @@protoc_insertion_point(field_get:gie.Property.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Property::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gie.Property.name)
}
inline std::string* Property::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gie.Property.name)
  return _s;
}
inline const std::string& Property::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Property::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Property::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Property::release_name() {
  // @@protoc_insertion_point(field_release:gie.Property.name)
  return _impl_.name_.Release();
}
inline void Property::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gie.Property.name)
}

// .gie.DataType type = 3;
inline void Property::clear_type() {
  _impl_.type_ = 0;
}
inline ::gie::DataType Property::_internal_type() const {
  return static_cast< ::gie::DataType >(_impl_.type_);
}
inline ::gie::DataType Property::type() const {
  // @@protoc_insertion_point(field_get:gie.Property.type)
  return _internal_type();
}
inline void Property::_internal_set_type(::gie::DataType value) {
  
  _impl_.type_ = value;
}
inline void Property::set_type(::gie::DataType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:gie.Property.type)
}

// -------------------------------------------------------------------

// VertexType

// uint32 id = 1;
inline void VertexType::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t VertexType::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t VertexType::id() const {
  // @@protoc_insertion_point(field_get:gie.VertexType.id)
  return _internal_id();
}
inline void VertexType::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void VertexType::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:gie.VertexType.id)
}

// string name = 2;
inline void VertexType::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& VertexType::name() const {
  // @@protoc_insertion_point(field_get:gie.VertexType.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VertexType::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gie.VertexType.name)
}
inline std::string* VertexType::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gie.VertexType.name)
  return _s;
}
inline const std::string& VertexType::_internal_name() const {
  return _impl_.name_.Get();
}
inline void VertexType::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* VertexType::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* VertexType::release_name() {
  // @@protoc_insertion_point(field_release:gie.VertexType.name)
  return _impl_.name_.Release();
}
inline void VertexType::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gie.VertexType.name)
}

// repeated .gie.Property properties = 3;
inline int VertexType::_internal_properties_size() const {
  return _impl_.properties_.size();
}
inline int VertexType::properties_size() const {
  return _internal_properties_size();
}
inline void VertexType::clear_properties() {
  _impl_.properties_.Clear();
}
inline ::gie::Property* VertexType::mutable_properties(int index) {
  // @@protoc_insertion_point(field_mutable:gie.VertexType.properties)
  return _impl_.properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gie::Property >*
VertexType::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_list:gie.VertexType.properties)
  return &_impl_.properties_;
}
inline const ::gie::Property& VertexType::_internal_properties(int index) const {
  return _impl_.properties_.Get(index);
}
inline const ::gie::Property& VertexType::properties(int index) const {
  // @@protoc_insertion_point(field_get:gie.VertexType.properties)
  return _internal_properties(index);
}
inline ::gie::Property* VertexType::_internal_add_properties() {
  return _impl_.properties_.Add();
}
inline ::gie::Property* VertexType::add_properties() {
  ::gie::Property* _add = _internal_add_properties();
  // @@protoc_insertion_point(field_add:gie.VertexType.properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gie::Property >&
VertexType::properties() const {
  // @@protoc_insertion_point(field_list:gie.VertexType.properties)
  return _impl_.properties_;
}

// repeated string primary_keys = 4;
inline int VertexType::_internal_primary_keys_size() const {
  return _impl_.primary_keys_.size();
}
inline int VertexType::primary_keys_size() const {
  return _internal_primary_keys_size();
}
inline void VertexType::clear_primary_keys() {
  _impl_.primary_keys_.Clear();
}
inline std::string* VertexType::add_primary_keys() {
  std::string* _s = _internal_add_primary_keys();
  // @@protoc_insertion_point(field_add_mutable:gie.VertexType.primary_keys)
  return _s;
}
inline const std::string& VertexType::_internal_primary_keys(int index) const {
  return _impl_.primary_keys_.Get(index);
}
inline const std::string& VertexType::primary_keys(int index) const {
  // @@protoc_insertion_point(field_get:gie.VertexType.primary_keys)
  return _internal_primary_keys(index);
}
inline std::string* VertexType::mutable_primary_keys(int index) {
  // @@protoc_insertion_point(field_mutable:gie.VertexType.primary_keys)
  return _impl_.primary_keys_.Mutable(index);
}
inline void VertexType::set_primary_keys(int index, const std::string& value) {
  _impl_.primary_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:gie.VertexType.primary_keys)
}
inline void VertexType::set_primary_keys(int index, std::string&& value) {
  _impl_.primary_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:gie.VertexType.primary_keys)
}
inline void VertexType::set_primary_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.primary_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:gie.VertexType.primary_keys)
}
inline void VertexType::set_primary_keys(int index, const char* value, size_t size) {
  _impl_.primary_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gie.VertexType.primary_keys)
}
inline std::string* VertexType::_internal_add_primary_keys() {
  return _impl_.primary_keys_.Add();
}
inline void VertexType::add_primary_keys(const std::string& value) {
  _impl_.primary_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:gie.VertexType.primary_keys)
}
inline void VertexType::add_primary_keys(std::string&& value) {
  _impl_.primary_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:gie.VertexType.primary_keys)
}
inline void VertexType::add_primary_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.primary_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:gie.VertexType.primary_keys)
}
inline void VertexType::add_primary_keys(const char* value, size_t size) {
  _impl_.primary_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:gie.VertexType.primary_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
VertexType::primary_keys() const {
  // @@protoc_insertion_point(field_list:gie.VertexType.primary_keys)
  return _impl_.primary_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
VertexType::mutable_primary_keys() {
  // @@protoc_insertion_point(field_mutable_list:gie.VertexType.primary_keys)
  return &_impl_.primary_keys_;
}

// .gie.VertexPartitionStrategy partition_strategy = 5;
inline void VertexType::clear_partition_strategy() {
  _impl_.partition_strategy_ = 0;
}
inline ::gie::VertexPartitionStrategy VertexType::_internal_partition_strategy() const {
  return static_cast< ::gie::VertexPartitionStrategy >(_impl_.partition_strategy_);
}
inline ::gie::VertexPartitionStrategy VertexType::partition_strategy() const {
  // @@protoc_insertion_point(field_get:gie.VertexType.partition_strategy)
  return _internal_partition_strategy();
}
inline void VertexType::_internal_set_partition_strategy(::gie::VertexPartitionStrategy value) {
  
  _impl_.partition_strategy_ = value;
}
inline void VertexType::set_partition_strategy(::gie::VertexPartitionStrategy value) {
  _internal_set_partition_strategy(value);
  // @@protoc_insertion_point(field_set:gie.VertexType.partition_strategy)
}

// .gie.PropertyPartitionStrategy property_partition_strategy = 6;
inline void VertexType::clear_property_partition_strategy() {
  _impl_.property_partition_strategy_ = 0;
}
inline ::gie::PropertyPartitionStrategy VertexType::_internal_property_partition_strategy() const {
  return static_cast< ::gie::PropertyPartitionStrategy >(_impl_.property_partition_strategy_);
}
inline ::gie::PropertyPartitionStrategy VertexType::property_partition_strategy() const {
  // @@protoc_insertion_point(field_get:gie.VertexType.property_partition_strategy)
  return _internal_property_partition_strategy();
}
inline void VertexType::_internal_set_property_partition_strategy(::gie::PropertyPartitionStrategy value) {
  
  _impl_.property_partition_strategy_ = value;
}
inline void VertexType::set_property_partition_strategy(::gie::PropertyPartitionStrategy value) {
  _internal_set_property_partition_strategy(value);
  // @@protoc_insertion_point(field_set:gie.VertexType.property_partition_strategy)
}

// int64 total_num = 7;
inline void VertexType::clear_total_num() {
  _impl_.total_num_ = int64_t{0};
}
inline int64_t VertexType::_internal_total_num() const {
  return _impl_.total_num_;
}
inline int64_t VertexType::total_num() const {
  // @@protoc_insertion_point(field_get:gie.VertexType.total_num)
  return _internal_total_num();
}
inline void VertexType::_internal_set_total_num(int64_t value) {
  
  _impl_.total_num_ = value;
}
inline void VertexType::set_total_num(int64_t value) {
  _internal_set_total_num(value);
  // @@protoc_insertion_point(field_set:gie.VertexType.total_num)
}

// -------------------------------------------------------------------

// EdgeType

// uint32 id = 1;
inline void EdgeType::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t EdgeType::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t EdgeType::id() const {
  // @@protoc_insertion_point(field_get:gie.EdgeType.id)
  return _internal_id();
}
inline void EdgeType::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void EdgeType::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:gie.EdgeType.id)
}

// string name = 2;
inline void EdgeType::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& EdgeType::name() const {
  // @@protoc_insertion_point(field_get:gie.EdgeType.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EdgeType::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gie.EdgeType.name)
}
inline std::string* EdgeType::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gie.EdgeType.name)
  return _s;
}
inline const std::string& EdgeType::_internal_name() const {
  return _impl_.name_.Get();
}
inline void EdgeType::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* EdgeType::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* EdgeType::release_name() {
  // @@protoc_insertion_point(field_release:gie.EdgeType.name)
  return _impl_.name_.Release();
}
inline void EdgeType::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gie.EdgeType.name)
}

// repeated .gie.Property properties = 3;
inline int EdgeType::_internal_properties_size() const {
  return _impl_.properties_.size();
}
inline int EdgeType::properties_size() const {
  return _internal_properties_size();
}
inline void EdgeType::clear_properties() {
  _impl_.properties_.Clear();
}
inline ::gie::Property* EdgeType::mutable_properties(int index) {
  // @@protoc_insertion_point(field_mutable:gie.EdgeType.properties)
  return _impl_.properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gie::Property >*
EdgeType::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_list:gie.EdgeType.properties)
  return &_impl_.properties_;
}
inline const ::gie::Property& EdgeType::_internal_properties(int index) const {
  return _impl_.properties_.Get(index);
}
inline const ::gie::Property& EdgeType::properties(int index) const {
  // @@protoc_insertion_point(field_get:gie.EdgeType.properties)
  return _internal_properties(index);
}
inline ::gie::Property* EdgeType::_internal_add_properties() {
  return _impl_.properties_.Add();
}
inline ::gie::Property* EdgeType::add_properties() {
  ::gie::Property* _add = _internal_add_properties();
  // @@protoc_insertion_point(field_add:gie.EdgeType.properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gie::Property >&
EdgeType::properties() const {
  // @@protoc_insertion_point(field_list:gie.EdgeType.properties)
  return _impl_.properties_;
}

// repeated string primary_keys = 4;
inline int EdgeType::_internal_primary_keys_size() const {
  return _impl_.primary_keys_.size();
}
inline int EdgeType::primary_keys_size() const {
  return _internal_primary_keys_size();
}
inline void EdgeType::clear_primary_keys() {
  _impl_.primary_keys_.Clear();
}
inline std::string* EdgeType::add_primary_keys() {
  std::string* _s = _internal_add_primary_keys();
  // @@protoc_insertion_point(field_add_mutable:gie.EdgeType.primary_keys)
  return _s;
}
inline const std::string& EdgeType::_internal_primary_keys(int index) const {
  return _impl_.primary_keys_.Get(index);
}
inline const std::string& EdgeType::primary_keys(int index) const {
  // @@protoc_insertion_point(field_get:gie.EdgeType.primary_keys)
  return _internal_primary_keys(index);
}
inline std::string* EdgeType::mutable_primary_keys(int index) {
  // @@protoc_insertion_point(field_mutable:gie.EdgeType.primary_keys)
  return _impl_.primary_keys_.Mutable(index);
}
inline void EdgeType::set_primary_keys(int index, const std::string& value) {
  _impl_.primary_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:gie.EdgeType.primary_keys)
}
inline void EdgeType::set_primary_keys(int index, std::string&& value) {
  _impl_.primary_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:gie.EdgeType.primary_keys)
}
inline void EdgeType::set_primary_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.primary_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:gie.EdgeType.primary_keys)
}
inline void EdgeType::set_primary_keys(int index, const char* value, size_t size) {
  _impl_.primary_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gie.EdgeType.primary_keys)
}
inline std::string* EdgeType::_internal_add_primary_keys() {
  return _impl_.primary_keys_.Add();
}
inline void EdgeType::add_primary_keys(const std::string& value) {
  _impl_.primary_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:gie.EdgeType.primary_keys)
}
inline void EdgeType::add_primary_keys(std::string&& value) {
  _impl_.primary_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:gie.EdgeType.primary_keys)
}
inline void EdgeType::add_primary_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.primary_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:gie.EdgeType.primary_keys)
}
inline void EdgeType::add_primary_keys(const char* value, size_t size) {
  _impl_.primary_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:gie.EdgeType.primary_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EdgeType::primary_keys() const {
  // @@protoc_insertion_point(field_list:gie.EdgeType.primary_keys)
  return _impl_.primary_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
EdgeType::mutable_primary_keys() {
  // @@protoc_insertion_point(field_mutable_list:gie.EdgeType.primary_keys)
  return &_impl_.primary_keys_;
}

// repeated .gie.SrcDstPair src_dst_pairs = 5;
inline int EdgeType::_internal_src_dst_pairs_size() const {
  return _impl_.src_dst_pairs_.size();
}
inline int EdgeType::src_dst_pairs_size() const {
  return _internal_src_dst_pairs_size();
}
inline void EdgeType::clear_src_dst_pairs() {
  _impl_.src_dst_pairs_.Clear();
}
inline ::gie::SrcDstPair* EdgeType::mutable_src_dst_pairs(int index) {
  // @@protoc_insertion_point(field_mutable:gie.EdgeType.src_dst_pairs)
  return _impl_.src_dst_pairs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gie::SrcDstPair >*
EdgeType::mutable_src_dst_pairs() {
  // @@protoc_insertion_point(field_mutable_list:gie.EdgeType.src_dst_pairs)
  return &_impl_.src_dst_pairs_;
}
inline const ::gie::SrcDstPair& EdgeType::_internal_src_dst_pairs(int index) const {
  return _impl_.src_dst_pairs_.Get(index);
}
inline const ::gie::SrcDstPair& EdgeType::src_dst_pairs(int index) const {
  // @@protoc_insertion_point(field_get:gie.EdgeType.src_dst_pairs)
  return _internal_src_dst_pairs(index);
}
inline ::gie::SrcDstPair* EdgeType::_internal_add_src_dst_pairs() {
  return _impl_.src_dst_pairs_.Add();
}
inline ::gie::SrcDstPair* EdgeType::add_src_dst_pairs() {
  ::gie::SrcDstPair* _add = _internal_add_src_dst_pairs();
  // @@protoc_insertion_point(field_add:gie.EdgeType.src_dst_pairs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gie::SrcDstPair >&
EdgeType::src_dst_pairs() const {
  // @@protoc_insertion_point(field_list:gie.EdgeType.src_dst_pairs)
  return _impl_.src_dst_pairs_;
}

// int64 total_num = 6;
inline void EdgeType::clear_total_num() {
  _impl_.total_num_ = int64_t{0};
}
inline int64_t EdgeType::_internal_total_num() const {
  return _impl_.total_num_;
}
inline int64_t EdgeType::total_num() const {
  // @@protoc_insertion_point(field_get:gie.EdgeType.total_num)
  return _internal_total_num();
}
inline void EdgeType::_internal_set_total_num(int64_t value) {
  
  _impl_.total_num_ = value;
}
inline void EdgeType::set_total_num(int64_t value) {
  _internal_set_total_num(value);
  // @@protoc_insertion_point(field_set:gie.EdgeType.total_num)
}

// -------------------------------------------------------------------

// Statistics

// uint32 num_partitions = 1;
inline void Statistics::clear_num_partitions() {
  _impl_.num_partitions_ = 0u;
}
inline uint32_t Statistics::_internal_num_partitions() const {
  return _impl_.num_partitions_;
}
inline uint32_t Statistics::num_partitions() const {
  // @@protoc_insertion_point(field_get:gie.Statistics.num_partitions)
  return _internal_num_partitions();
}
inline void Statistics::_internal_set_num_partitions(uint32_t value) {
  
  _impl_.num_partitions_ = value;
}
inline void Statistics::set_num_partitions(uint32_t value) {
  _internal_set_num_partitions(value);
  // @@protoc_insertion_point(field_set:gie.Statistics.num_partitions)
}

// uint64 num_vertices = 2;
inline void Statistics::clear_num_vertices() {
  _impl_.num_vertices_ = uint64_t{0u};
}
inline uint64_t Statistics::_internal_num_vertices() const {
  return _impl_.num_vertices_;
}
inline uint64_t Statistics::num_vertices() const {
  // @@protoc_insertion_point(field_get:gie.Statistics.num_vertices)
  return _internal_num_vertices();
}
inline void Statistics::_internal_set_num_vertices(uint64_t value) {
  
  _impl_.num_vertices_ = value;
}
inline void Statistics::set_num_vertices(uint64_t value) {
  _internal_set_num_vertices(value);
  // @@protoc_insertion_point(field_set:gie.Statistics.num_vertices)
}

// uint64 num_edges = 3;
inline void Statistics::clear_num_edges() {
  _impl_.num_edges_ = uint64_t{0u};
}
inline uint64_t Statistics::_internal_num_edges() const {
  return _impl_.num_edges_;
}
inline uint64_t Statistics::num_edges() const {
  // @@protoc_insertion_point(field_get:gie.Statistics.num_edges)
  return _internal_num_edges();
}
inline void Statistics::_internal_set_num_edges(uint64_t value) {
  
  _impl_.num_edges_ = value;
}
inline void Statistics::set_num_edges(uint64_t value) {
  _internal_set_num_edges(value);
  // @@protoc_insertion_point(field_set:gie.Statistics.num_edges)
}

// -------------------------------------------------------------------

// Schema

// .gie.GraphPartitionStrategy partition_strategy = 1;
inline bool Schema::_internal_has_partition_strategy() const {
  return this != internal_default_instance() && _impl_.partition_strategy_ != nullptr;
}
inline bool Schema::has_partition_strategy() const {
  return _internal_has_partition_strategy();
}
inline void Schema::clear_partition_strategy() {
  if (GetArenaForAllocation() == nullptr && _impl_.partition_strategy_ != nullptr) {
    delete _impl_.partition_strategy_;
  }
  _impl_.partition_strategy_ = nullptr;
}
inline const ::gie::GraphPartitionStrategy& Schema::_internal_partition_strategy() const {
  const ::gie::GraphPartitionStrategy* p = _impl_.partition_strategy_;
  return p != nullptr ? *p : reinterpret_cast<const ::gie::GraphPartitionStrategy&>(
      ::gie::_GraphPartitionStrategy_default_instance_);
}
inline const ::gie::GraphPartitionStrategy& Schema::partition_strategy() const {
  // @@protoc_insertion_point(field_get:gie.Schema.partition_strategy)
  return _internal_partition_strategy();
}
inline void Schema::unsafe_arena_set_allocated_partition_strategy(
    ::gie::GraphPartitionStrategy* partition_strategy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.partition_strategy_);
  }
  _impl_.partition_strategy_ = partition_strategy;
  if (partition_strategy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gie.Schema.partition_strategy)
}
inline ::gie::GraphPartitionStrategy* Schema::release_partition_strategy() {
  
  ::gie::GraphPartitionStrategy* temp = _impl_.partition_strategy_;
  _impl_.partition_strategy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gie::GraphPartitionStrategy* Schema::unsafe_arena_release_partition_strategy() {
  // @@protoc_insertion_point(field_release:gie.Schema.partition_strategy)
  
  ::gie::GraphPartitionStrategy* temp = _impl_.partition_strategy_;
  _impl_.partition_strategy_ = nullptr;
  return temp;
}
inline ::gie::GraphPartitionStrategy* Schema::_internal_mutable_partition_strategy() {
  
  if (_impl_.partition_strategy_ == nullptr) {
    auto* p = CreateMaybeMessage<::gie::GraphPartitionStrategy>(GetArenaForAllocation());
    _impl_.partition_strategy_ = p;
  }
  return _impl_.partition_strategy_;
}
inline ::gie::GraphPartitionStrategy* Schema::mutable_partition_strategy() {
  ::gie::GraphPartitionStrategy* _msg = _internal_mutable_partition_strategy();
  // @@protoc_insertion_point(field_mutable:gie.Schema.partition_strategy)
  return _msg;
}
inline void Schema::set_allocated_partition_strategy(::gie::GraphPartitionStrategy* partition_strategy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.partition_strategy_;
  }
  if (partition_strategy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(partition_strategy);
    if (message_arena != submessage_arena) {
      partition_strategy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partition_strategy, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.partition_strategy_ = partition_strategy;
  // @@protoc_insertion_point(field_set_allocated:gie.Schema.partition_strategy)
}

// repeated .gie.VertexType vertex_types = 2;
inline int Schema::_internal_vertex_types_size() const {
  return _impl_.vertex_types_.size();
}
inline int Schema::vertex_types_size() const {
  return _internal_vertex_types_size();
}
inline void Schema::clear_vertex_types() {
  _impl_.vertex_types_.Clear();
}
inline ::gie::VertexType* Schema::mutable_vertex_types(int index) {
  // @@protoc_insertion_point(field_mutable:gie.Schema.vertex_types)
  return _impl_.vertex_types_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gie::VertexType >*
Schema::mutable_vertex_types() {
  // @@protoc_insertion_point(field_mutable_list:gie.Schema.vertex_types)
  return &_impl_.vertex_types_;
}
inline const ::gie::VertexType& Schema::_internal_vertex_types(int index) const {
  return _impl_.vertex_types_.Get(index);
}
inline const ::gie::VertexType& Schema::vertex_types(int index) const {
  // @@protoc_insertion_point(field_get:gie.Schema.vertex_types)
  return _internal_vertex_types(index);
}
inline ::gie::VertexType* Schema::_internal_add_vertex_types() {
  return _impl_.vertex_types_.Add();
}
inline ::gie::VertexType* Schema::add_vertex_types() {
  ::gie::VertexType* _add = _internal_add_vertex_types();
  // @@protoc_insertion_point(field_add:gie.Schema.vertex_types)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gie::VertexType >&
Schema::vertex_types() const {
  // @@protoc_insertion_point(field_list:gie.Schema.vertex_types)
  return _impl_.vertex_types_;
}

// repeated .gie.EdgeType edge_types = 3;
inline int Schema::_internal_edge_types_size() const {
  return _impl_.edge_types_.size();
}
inline int Schema::edge_types_size() const {
  return _internal_edge_types_size();
}
inline void Schema::clear_edge_types() {
  _impl_.edge_types_.Clear();
}
inline ::gie::EdgeType* Schema::mutable_edge_types(int index) {
  // @@protoc_insertion_point(field_mutable:gie.Schema.edge_types)
  return _impl_.edge_types_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gie::EdgeType >*
Schema::mutable_edge_types() {
  // @@protoc_insertion_point(field_mutable_list:gie.Schema.edge_types)
  return &_impl_.edge_types_;
}
inline const ::gie::EdgeType& Schema::_internal_edge_types(int index) const {
  return _impl_.edge_types_.Get(index);
}
inline const ::gie::EdgeType& Schema::edge_types(int index) const {
  // @@protoc_insertion_point(field_get:gie.Schema.edge_types)
  return _internal_edge_types(index);
}
inline ::gie::EdgeType* Schema::_internal_add_edge_types() {
  return _impl_.edge_types_.Add();
}
inline ::gie::EdgeType* Schema::add_edge_types() {
  ::gie::EdgeType* _add = _internal_add_edge_types();
  // @@protoc_insertion_point(field_add:gie.Schema.edge_types)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gie::EdgeType >&
Schema::edge_types() const {
  // @@protoc_insertion_point(field_list:gie.Schema.edge_types)
  return _impl_.edge_types_;
}

// .gie.Statistics statistics = 4;
inline bool Schema::_internal_has_statistics() const {
  return this != internal_default_instance() && _impl_.statistics_ != nullptr;
}
inline bool Schema::has_statistics() const {
  return _internal_has_statistics();
}
inline void Schema::clear_statistics() {
  if (GetArenaForAllocation() == nullptr && _impl_.statistics_ != nullptr) {
    delete _impl_.statistics_;
  }
  _impl_.statistics_ = nullptr;
}
inline const ::gie::Statistics& Schema::_internal_statistics() const {
  const ::gie::Statistics* p = _impl_.statistics_;
  return p != nullptr ? *p : reinterpret_cast<const ::gie::Statistics&>(
      ::gie::_Statistics_default_instance_);
}
inline const ::gie::Statistics& Schema::statistics() const {
  // @@protoc_insertion_point(field_get:gie.Schema.statistics)
  return _internal_statistics();
}
inline void Schema::unsafe_arena_set_allocated_statistics(
    ::gie::Statistics* statistics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statistics_);
  }
  _impl_.statistics_ = statistics;
  if (statistics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gie.Schema.statistics)
}
inline ::gie::Statistics* Schema::release_statistics() {
  
  ::gie::Statistics* temp = _impl_.statistics_;
  _impl_.statistics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gie::Statistics* Schema::unsafe_arena_release_statistics() {
  // @@protoc_insertion_point(field_release:gie.Schema.statistics)
  
  ::gie::Statistics* temp = _impl_.statistics_;
  _impl_.statistics_ = nullptr;
  return temp;
}
inline ::gie::Statistics* Schema::_internal_mutable_statistics() {
  
  if (_impl_.statistics_ == nullptr) {
    auto* p = CreateMaybeMessage<::gie::Statistics>(GetArenaForAllocation());
    _impl_.statistics_ = p;
  }
  return _impl_.statistics_;
}
inline ::gie::Statistics* Schema::mutable_statistics() {
  ::gie::Statistics* _msg = _internal_mutable_statistics();
  // @@protoc_insertion_point(field_mutable:gie.Schema.statistics)
  return _msg;
}
inline void Schema::set_allocated_statistics(::gie::Statistics* statistics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.statistics_;
  }
  if (statistics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(statistics);
    if (message_arena != submessage_arena) {
      statistics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statistics, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.statistics_ = statistics;
  // @@protoc_insertion_point(field_set_allocated:gie.Schema.statistics)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace gie

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::gie::VertexPartitionStrategy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gie::VertexPartitionStrategy>() {
  return ::gie::VertexPartitionStrategy_descriptor();
}
template <> struct is_proto_enum< ::gie::EdgePartitionStrategy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gie::EdgePartitionStrategy>() {
  return ::gie::EdgePartitionStrategy_descriptor();
}
template <> struct is_proto_enum< ::gie::PropertyPartitionStrategy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gie::PropertyPartitionStrategy>() {
  return ::gie::PropertyPartitionStrategy_descriptor();
}
template <> struct is_proto_enum< ::gie::GraphTopologyPartitionStrategy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gie::GraphTopologyPartitionStrategy>() {
  return ::gie::GraphTopologyPartitionStrategy_descriptor();
}
template <> struct is_proto_enum< ::gie::Relation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gie::Relation>() {
  return ::gie::Relation_descriptor();
}
template <> struct is_proto_enum< ::gie::DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gie::DataType>() {
  return ::gie::DataType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_gie_5fschema_2eproto
