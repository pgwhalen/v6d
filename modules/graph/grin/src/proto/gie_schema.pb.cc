// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gie_schema.proto

#include "gie_schema.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace gie {
PROTOBUF_CONSTEXPR PropertyPartitionByEntityStrategy::PropertyPartitionByEntityStrategy(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vertex_property_partition_strategy_)*/0
  , /*decltype(_impl_.edge_property_partition_strategy_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PropertyPartitionByEntityStrategyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PropertyPartitionByEntityStrategyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PropertyPartitionByEntityStrategyDefaultTypeInternal() {}
  union {
    PropertyPartitionByEntityStrategy _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PropertyPartitionByEntityStrategyDefaultTypeInternal _PropertyPartitionByEntityStrategy_default_instance_;
PROTOBUF_CONSTEXPR PropertyPartitionByTypeStrategy::PropertyPartitionByTypeStrategy(
    ::_pbi::ConstantInitialized) {}
struct PropertyPartitionByTypeStrategyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PropertyPartitionByTypeStrategyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PropertyPartitionByTypeStrategyDefaultTypeInternal() {}
  union {
    PropertyPartitionByTypeStrategy _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PropertyPartitionByTypeStrategyDefaultTypeInternal _PropertyPartitionByTypeStrategy_default_instance_;
PROTOBUF_CONSTEXPR GraphPropertyPartitionStrategy::GraphPropertyPartitionStrategy(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.item_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct GraphPropertyPartitionStrategyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GraphPropertyPartitionStrategyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GraphPropertyPartitionStrategyDefaultTypeInternal() {}
  union {
    GraphPropertyPartitionStrategy _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GraphPropertyPartitionStrategyDefaultTypeInternal _GraphPropertyPartitionStrategy_default_instance_;
PROTOBUF_CONSTEXPR GraphPartitionStrategy::GraphPartitionStrategy(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.property_)*/nullptr
  , /*decltype(_impl_.topology_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GraphPartitionStrategyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GraphPartitionStrategyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GraphPartitionStrategyDefaultTypeInternal() {}
  union {
    GraphPartitionStrategy _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GraphPartitionStrategyDefaultTypeInternal _GraphPartitionStrategy_default_instance_;
PROTOBUF_CONSTEXPR SrcDstPair::SrcDstPair(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.src_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dst_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.partition_strategy_)*/0
  , /*decltype(_impl_.property_partition_strategy_)*/0
  , /*decltype(_impl_.relation_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SrcDstPairDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SrcDstPairDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SrcDstPairDefaultTypeInternal() {}
  union {
    SrcDstPair _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SrcDstPairDefaultTypeInternal _SrcDstPair_default_instance_;
PROTOBUF_CONSTEXPR Property::Property(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/0u
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PropertyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PropertyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PropertyDefaultTypeInternal() {}
  union {
    Property _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PropertyDefaultTypeInternal _Property_default_instance_;
PROTOBUF_CONSTEXPR VertexType::VertexType(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.properties_)*/{}
  , /*decltype(_impl_.primary_keys_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/0u
  , /*decltype(_impl_.partition_strategy_)*/0
  , /*decltype(_impl_.total_num_)*/int64_t{0}
  , /*decltype(_impl_.property_partition_strategy_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VertexTypeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VertexTypeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VertexTypeDefaultTypeInternal() {}
  union {
    VertexType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VertexTypeDefaultTypeInternal _VertexType_default_instance_;
PROTOBUF_CONSTEXPR EdgeType::EdgeType(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.properties_)*/{}
  , /*decltype(_impl_.primary_keys_)*/{}
  , /*decltype(_impl_.src_dst_pairs_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.total_num_)*/int64_t{0}
  , /*decltype(_impl_.id_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EdgeTypeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EdgeTypeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EdgeTypeDefaultTypeInternal() {}
  union {
    EdgeType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EdgeTypeDefaultTypeInternal _EdgeType_default_instance_;
PROTOBUF_CONSTEXPR Statistics::Statistics(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.num_vertices_)*/uint64_t{0u}
  , /*decltype(_impl_.num_edges_)*/uint64_t{0u}
  , /*decltype(_impl_.num_partitions_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatisticsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatisticsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatisticsDefaultTypeInternal() {}
  union {
    Statistics _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatisticsDefaultTypeInternal _Statistics_default_instance_;
PROTOBUF_CONSTEXPR Schema::Schema(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vertex_types_)*/{}
  , /*decltype(_impl_.edge_types_)*/{}
  , /*decltype(_impl_.partition_strategy_)*/nullptr
  , /*decltype(_impl_.statistics_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SchemaDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchemaDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchemaDefaultTypeInternal() {}
  union {
    Schema _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchemaDefaultTypeInternal _Schema_default_instance_;
}  // namespace gie
static ::_pb::Metadata file_level_metadata_gie_5fschema_2eproto[10];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_gie_5fschema_2eproto[6];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_gie_5fschema_2eproto = nullptr;

const uint32_t TableStruct_gie_5fschema_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gie::PropertyPartitionByEntityStrategy, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gie::PropertyPartitionByEntityStrategy, _impl_.vertex_property_partition_strategy_),
  PROTOBUF_FIELD_OFFSET(::gie::PropertyPartitionByEntityStrategy, _impl_.edge_property_partition_strategy_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gie::PropertyPartitionByTypeStrategy, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gie::GraphPropertyPartitionStrategy, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::gie::GraphPropertyPartitionStrategy, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::gie::GraphPropertyPartitionStrategy, _impl_.item_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gie::GraphPartitionStrategy, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gie::GraphPartitionStrategy, _impl_.topology_),
  PROTOBUF_FIELD_OFFSET(::gie::GraphPartitionStrategy, _impl_.property_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gie::SrcDstPair, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gie::SrcDstPair, _impl_.src_type_),
  PROTOBUF_FIELD_OFFSET(::gie::SrcDstPair, _impl_.dst_type_),
  PROTOBUF_FIELD_OFFSET(::gie::SrcDstPair, _impl_.partition_strategy_),
  PROTOBUF_FIELD_OFFSET(::gie::SrcDstPair, _impl_.property_partition_strategy_),
  PROTOBUF_FIELD_OFFSET(::gie::SrcDstPair, _impl_.relation_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gie::Property, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gie::Property, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::gie::Property, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gie::Property, _impl_.type_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gie::VertexType, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gie::VertexType, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::gie::VertexType, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gie::VertexType, _impl_.properties_),
  PROTOBUF_FIELD_OFFSET(::gie::VertexType, _impl_.primary_keys_),
  PROTOBUF_FIELD_OFFSET(::gie::VertexType, _impl_.partition_strategy_),
  PROTOBUF_FIELD_OFFSET(::gie::VertexType, _impl_.property_partition_strategy_),
  PROTOBUF_FIELD_OFFSET(::gie::VertexType, _impl_.total_num_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gie::EdgeType, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gie::EdgeType, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::gie::EdgeType, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::gie::EdgeType, _impl_.properties_),
  PROTOBUF_FIELD_OFFSET(::gie::EdgeType, _impl_.primary_keys_),
  PROTOBUF_FIELD_OFFSET(::gie::EdgeType, _impl_.src_dst_pairs_),
  PROTOBUF_FIELD_OFFSET(::gie::EdgeType, _impl_.total_num_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gie::Statistics, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gie::Statistics, _impl_.num_partitions_),
  PROTOBUF_FIELD_OFFSET(::gie::Statistics, _impl_.num_vertices_),
  PROTOBUF_FIELD_OFFSET(::gie::Statistics, _impl_.num_edges_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::gie::Schema, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::gie::Schema, _impl_.partition_strategy_),
  PROTOBUF_FIELD_OFFSET(::gie::Schema, _impl_.vertex_types_),
  PROTOBUF_FIELD_OFFSET(::gie::Schema, _impl_.edge_types_),
  PROTOBUF_FIELD_OFFSET(::gie::Schema, _impl_.statistics_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::gie::PropertyPartitionByEntityStrategy)},
  { 8, -1, -1, sizeof(::gie::PropertyPartitionByTypeStrategy)},
  { 14, -1, -1, sizeof(::gie::GraphPropertyPartitionStrategy)},
  { 23, -1, -1, sizeof(::gie::GraphPartitionStrategy)},
  { 31, -1, -1, sizeof(::gie::SrcDstPair)},
  { 42, -1, -1, sizeof(::gie::Property)},
  { 51, -1, -1, sizeof(::gie::VertexType)},
  { 64, -1, -1, sizeof(::gie::EdgeType)},
  { 76, -1, -1, sizeof(::gie::Statistics)},
  { 85, -1, -1, sizeof(::gie::Schema)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::gie::_PropertyPartitionByEntityStrategy_default_instance_._instance,
  &::gie::_PropertyPartitionByTypeStrategy_default_instance_._instance,
  &::gie::_GraphPropertyPartitionStrategy_default_instance_._instance,
  &::gie::_GraphPartitionStrategy_default_instance_._instance,
  &::gie::_SrcDstPair_default_instance_._instance,
  &::gie::_Property_default_instance_._instance,
  &::gie::_VertexType_default_instance_._instance,
  &::gie::_EdgeType_default_instance_._instance,
  &::gie::_Statistics_default_instance_._instance,
  &::gie::_Schema_default_instance_._instance,
};

const char descriptor_table_protodef_gie_5fschema_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\020gie_schema.proto\022\003gie\"\271\001\n!PropertyPart"
  "itionByEntityStrategy\022J\n\"vertex_property"
  "_partition_strategy\030\001 \001(\0162\036.gie.Property"
  "PartitionStrategy\022H\n edge_property_parti"
  "tion_strategy\030\002 \001(\0162\036.gie.PropertyPartit"
  "ionStrategy\"!\n\037PropertyPartitionByTypeSt"
  "rategy\"\236\001\n\036GraphPropertyPartitionStrateg"
  "y\022;\n\tby_entity\030\001 \001(\0132&.gie.PropertyParti"
  "tionByEntityStrategyH\000\0227\n\007by_type\030\002 \001(\0132"
  "$.gie.PropertyPartitionByTypeStrategyH\000B"
  "\006\n\004item\"\206\001\n\026GraphPartitionStrategy\0225\n\010to"
  "pology\030\001 \001(\0162#.gie.GraphTopologyPartitio"
  "nStrategy\0225\n\010property\030\002 \001(\0132#.gie.GraphP"
  "ropertyPartitionStrategy\"\316\001\n\nSrcDstPair\022"
  "\020\n\010src_type\030\001 \001(\t\022\020\n\010dst_type\030\002 \001(\t\0226\n\022p"
  "artition_strategy\030\003 \001(\0162\032.gie.EdgePartit"
  "ionStrategy\022C\n\033property_partition_strate"
  "gy\030\004 \001(\0162\036.gie.PropertyPartitionStrategy"
  "\022\037\n\010relation\030\005 \001(\0162\r.gie.Relation\"A\n\010Pro"
  "perty\022\n\n\002id\030\001 \001(\r\022\014\n\004name\030\002 \001(\t\022\033\n\004type\030"
  "\003 \001(\0162\r.gie.DataType\"\361\001\n\nVertexType\022\n\n\002i"
  "d\030\001 \001(\r\022\014\n\004name\030\002 \001(\t\022!\n\nproperties\030\003 \003("
  "\0132\r.gie.Property\022\024\n\014primary_keys\030\004 \003(\t\0228"
  "\n\022partition_strategy\030\005 \001(\0162\034.gie.VertexP"
  "artitionStrategy\022C\n\033property_partition_s"
  "trategy\030\006 \001(\0162\036.gie.PropertyPartitionStr"
  "ategy\022\021\n\ttotal_num\030\007 \001(\003\"\230\001\n\010EdgeType\022\n\n"
  "\002id\030\001 \001(\r\022\014\n\004name\030\002 \001(\t\022!\n\nproperties\030\003 "
  "\003(\0132\r.gie.Property\022\024\n\014primary_keys\030\004 \003(\t"
  "\022&\n\rsrc_dst_pairs\030\005 \003(\0132\017.gie.SrcDstPair"
  "\022\021\n\ttotal_num\030\006 \001(\003\"M\n\nStatistics\022\026\n\016num"
  "_partitions\030\001 \001(\r\022\024\n\014num_vertices\030\002 \001(\004\022"
  "\021\n\tnum_edges\030\003 \001(\004\"\260\001\n\006Schema\0227\n\022partiti"
  "on_strategy\030\001 \001(\0132\033.gie.GraphPartitionSt"
  "rategy\022%\n\014vertex_types\030\002 \003(\0132\017.gie.Verte"
  "xType\022!\n\nedge_types\030\003 \003(\0132\r.gie.EdgeType"
  "\022#\n\nstatistics\030\004 \001(\0132\017.gie.Statistics*[\n"
  "\027VertexPartitionStrategy\022\021\n\rVPS_UNDEFINE"
  "D\020\000\022\013\n\007VPS_ALL\020\001\022\013\n\007VPS_ONE\020\002\022\023\n\017VPS_FOL"
  "LOW_EDGE\020\003*\201\001\n\025EdgePartitionStrategy\022\021\n\r"
  "EPS_UNDEFINED\020\000\022\013\n\007EPS_ALL\020\001\022\013\n\007EPS_ONE\020"
  "\002\022\022\n\016EPS_FOLLOW_SRC\020\003\022\022\n\016EPS_FOLLOW_DST\020"
  "\004\022\023\n\017EPS_FOLLOW_BOTH\020\005*U\n\031PropertyPartit"
  "ionStrategy\022\021\n\rPPS_UNDEFINED\020\000\022\016\n\nPPS_MA"
  "STER\020\001\022\025\n\021PPS_MASTER_MIRROR\020\002*\306\001\n\036GraphT"
  "opologyPartitionStrategy\022\021\n\rGPS_UNDEFINE"
  "D\020\000\022\025\n\021GPS_ALL_REPLICATE\020\001\022\034\n\030GPS_EDGE_C"
  "UT_FOLLOW_BOTH\020\002\022\033\n\027GPS_EDGE_CUT_FOLLOW_"
  "SRC\020\003\022\033\n\027GPS_EDGE_CUT_FOLLOW_DST\020\004\022\022\n\016GP"
  "S_VERTEX_CUT\020\005\022\016\n\nGPS_HYBRID\020\006*a\n\010Relati"
  "on\022\021\n\rREL_UNDEFINED\020\000\022\020\n\014MANY_TO_MANY\020\001\022"
  "\017\n\013MANY_TO_ONE\020\002\022\017\n\013ONE_TO_MANY\020\003\022\016\n\nONE"
  "_TO_ONE\020\004*\312\001\n\010DataType\022\016\n\nDT_UNKNOWN\020\000\022\023"
  "\n\017DT_SIGNED_INT32\020\001\022\025\n\021DT_UNSIGNED_INT32"
  "\020\002\022\023\n\017DT_SIGNED_INT64\020\003\022\025\n\021DT_UNSIGNED_I"
  "NT64\020\004\022\014\n\010DT_FLOAT\020\005\022\r\n\tDT_DOUBLE\020\006\022\r\n\tD"
  "T_STRING\020\007\022\013\n\007DT_DATE\020\010\022\013\n\007DT_TIME\020\t\022\020\n\014"
  "DT_TIMESTAMP\020\nB%\n#com.alibaba.graphscope"
  ".proto.schemab\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_gie_5fschema_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_gie_5fschema_2eproto = {
    false, false, 2341, descriptor_table_protodef_gie_5fschema_2eproto,
    "gie_schema.proto",
    &descriptor_table_gie_5fschema_2eproto_once, nullptr, 0, 10,
    schemas, file_default_instances, TableStruct_gie_5fschema_2eproto::offsets,
    file_level_metadata_gie_5fschema_2eproto, file_level_enum_descriptors_gie_5fschema_2eproto,
    file_level_service_descriptors_gie_5fschema_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_gie_5fschema_2eproto_getter() {
  return &descriptor_table_gie_5fschema_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_gie_5fschema_2eproto(&descriptor_table_gie_5fschema_2eproto);
namespace gie {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VertexPartitionStrategy_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_gie_5fschema_2eproto);
  return file_level_enum_descriptors_gie_5fschema_2eproto[0];
}
bool VertexPartitionStrategy_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EdgePartitionStrategy_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_gie_5fschema_2eproto);
  return file_level_enum_descriptors_gie_5fschema_2eproto[1];
}
bool EdgePartitionStrategy_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PropertyPartitionStrategy_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_gie_5fschema_2eproto);
  return file_level_enum_descriptors_gie_5fschema_2eproto[2];
}
bool PropertyPartitionStrategy_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GraphTopologyPartitionStrategy_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_gie_5fschema_2eproto);
  return file_level_enum_descriptors_gie_5fschema_2eproto[3];
}
bool GraphTopologyPartitionStrategy_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Relation_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_gie_5fschema_2eproto);
  return file_level_enum_descriptors_gie_5fschema_2eproto[4];
}
bool Relation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_gie_5fschema_2eproto);
  return file_level_enum_descriptors_gie_5fschema_2eproto[5];
}
bool DataType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class PropertyPartitionByEntityStrategy::_Internal {
 public:
};

PropertyPartitionByEntityStrategy::PropertyPartitionByEntityStrategy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gie.PropertyPartitionByEntityStrategy)
}
PropertyPartitionByEntityStrategy::PropertyPartitionByEntityStrategy(const PropertyPartitionByEntityStrategy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PropertyPartitionByEntityStrategy* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.vertex_property_partition_strategy_){}
    , decltype(_impl_.edge_property_partition_strategy_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.vertex_property_partition_strategy_, &from._impl_.vertex_property_partition_strategy_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.edge_property_partition_strategy_) -
    reinterpret_cast<char*>(&_impl_.vertex_property_partition_strategy_)) + sizeof(_impl_.edge_property_partition_strategy_));
  // @@protoc_insertion_point(copy_constructor:gie.PropertyPartitionByEntityStrategy)
}

inline void PropertyPartitionByEntityStrategy::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.vertex_property_partition_strategy_){0}
    , decltype(_impl_.edge_property_partition_strategy_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PropertyPartitionByEntityStrategy::~PropertyPartitionByEntityStrategy() {
  // @@protoc_insertion_point(destructor:gie.PropertyPartitionByEntityStrategy)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PropertyPartitionByEntityStrategy::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PropertyPartitionByEntityStrategy::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PropertyPartitionByEntityStrategy::Clear() {
// @@protoc_insertion_point(message_clear_start:gie.PropertyPartitionByEntityStrategy)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.vertex_property_partition_strategy_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.edge_property_partition_strategy_) -
      reinterpret_cast<char*>(&_impl_.vertex_property_partition_strategy_)) + sizeof(_impl_.edge_property_partition_strategy_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PropertyPartitionByEntityStrategy::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .gie.PropertyPartitionStrategy vertex_property_partition_strategy = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_vertex_property_partition_strategy(static_cast<::gie::PropertyPartitionStrategy>(val));
        } else
          goto handle_unusual;
        continue;
      // .gie.PropertyPartitionStrategy edge_property_partition_strategy = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_edge_property_partition_strategy(static_cast<::gie::PropertyPartitionStrategy>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PropertyPartitionByEntityStrategy::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gie.PropertyPartitionByEntityStrategy)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .gie.PropertyPartitionStrategy vertex_property_partition_strategy = 1;
  if (this->_internal_vertex_property_partition_strategy() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_vertex_property_partition_strategy(), target);
  }

  // .gie.PropertyPartitionStrategy edge_property_partition_strategy = 2;
  if (this->_internal_edge_property_partition_strategy() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_edge_property_partition_strategy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gie.PropertyPartitionByEntityStrategy)
  return target;
}

size_t PropertyPartitionByEntityStrategy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gie.PropertyPartitionByEntityStrategy)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .gie.PropertyPartitionStrategy vertex_property_partition_strategy = 1;
  if (this->_internal_vertex_property_partition_strategy() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_vertex_property_partition_strategy());
  }

  // .gie.PropertyPartitionStrategy edge_property_partition_strategy = 2;
  if (this->_internal_edge_property_partition_strategy() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_edge_property_partition_strategy());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PropertyPartitionByEntityStrategy::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PropertyPartitionByEntityStrategy::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PropertyPartitionByEntityStrategy::GetClassData() const { return &_class_data_; }


void PropertyPartitionByEntityStrategy::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PropertyPartitionByEntityStrategy*>(&to_msg);
  auto& from = static_cast<const PropertyPartitionByEntityStrategy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gie.PropertyPartitionByEntityStrategy)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_vertex_property_partition_strategy() != 0) {
    _this->_internal_set_vertex_property_partition_strategy(from._internal_vertex_property_partition_strategy());
  }
  if (from._internal_edge_property_partition_strategy() != 0) {
    _this->_internal_set_edge_property_partition_strategy(from._internal_edge_property_partition_strategy());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PropertyPartitionByEntityStrategy::CopyFrom(const PropertyPartitionByEntityStrategy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gie.PropertyPartitionByEntityStrategy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PropertyPartitionByEntityStrategy::IsInitialized() const {
  return true;
}

void PropertyPartitionByEntityStrategy::InternalSwap(PropertyPartitionByEntityStrategy* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PropertyPartitionByEntityStrategy, _impl_.edge_property_partition_strategy_)
      + sizeof(PropertyPartitionByEntityStrategy::_impl_.edge_property_partition_strategy_)
      - PROTOBUF_FIELD_OFFSET(PropertyPartitionByEntityStrategy, _impl_.vertex_property_partition_strategy_)>(
          reinterpret_cast<char*>(&_impl_.vertex_property_partition_strategy_),
          reinterpret_cast<char*>(&other->_impl_.vertex_property_partition_strategy_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PropertyPartitionByEntityStrategy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gie_5fschema_2eproto_getter, &descriptor_table_gie_5fschema_2eproto_once,
      file_level_metadata_gie_5fschema_2eproto[0]);
}

// ===================================================================

class PropertyPartitionByTypeStrategy::_Internal {
 public:
};

PropertyPartitionByTypeStrategy::PropertyPartitionByTypeStrategy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:gie.PropertyPartitionByTypeStrategy)
}
PropertyPartitionByTypeStrategy::PropertyPartitionByTypeStrategy(const PropertyPartitionByTypeStrategy& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  PropertyPartitionByTypeStrategy* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:gie.PropertyPartitionByTypeStrategy)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PropertyPartitionByTypeStrategy::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PropertyPartitionByTypeStrategy::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata PropertyPartitionByTypeStrategy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gie_5fschema_2eproto_getter, &descriptor_table_gie_5fschema_2eproto_once,
      file_level_metadata_gie_5fschema_2eproto[1]);
}

// ===================================================================

class GraphPropertyPartitionStrategy::_Internal {
 public:
  static const ::gie::PropertyPartitionByEntityStrategy& by_entity(const GraphPropertyPartitionStrategy* msg);
  static const ::gie::PropertyPartitionByTypeStrategy& by_type(const GraphPropertyPartitionStrategy* msg);
};

const ::gie::PropertyPartitionByEntityStrategy&
GraphPropertyPartitionStrategy::_Internal::by_entity(const GraphPropertyPartitionStrategy* msg) {
  return *msg->_impl_.item_.by_entity_;
}
const ::gie::PropertyPartitionByTypeStrategy&
GraphPropertyPartitionStrategy::_Internal::by_type(const GraphPropertyPartitionStrategy* msg) {
  return *msg->_impl_.item_.by_type_;
}
void GraphPropertyPartitionStrategy::set_allocated_by_entity(::gie::PropertyPartitionByEntityStrategy* by_entity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_item();
  if (by_entity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(by_entity);
    if (message_arena != submessage_arena) {
      by_entity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, by_entity, submessage_arena);
    }
    set_has_by_entity();
    _impl_.item_.by_entity_ = by_entity;
  }
  // @@protoc_insertion_point(field_set_allocated:gie.GraphPropertyPartitionStrategy.by_entity)
}
void GraphPropertyPartitionStrategy::set_allocated_by_type(::gie::PropertyPartitionByTypeStrategy* by_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_item();
  if (by_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(by_type);
    if (message_arena != submessage_arena) {
      by_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, by_type, submessage_arena);
    }
    set_has_by_type();
    _impl_.item_.by_type_ = by_type;
  }
  // @@protoc_insertion_point(field_set_allocated:gie.GraphPropertyPartitionStrategy.by_type)
}
GraphPropertyPartitionStrategy::GraphPropertyPartitionStrategy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gie.GraphPropertyPartitionStrategy)
}
GraphPropertyPartitionStrategy::GraphPropertyPartitionStrategy(const GraphPropertyPartitionStrategy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GraphPropertyPartitionStrategy* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.item_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_item();
  switch (from.item_case()) {
    case kByEntity: {
      _this->_internal_mutable_by_entity()->::gie::PropertyPartitionByEntityStrategy::MergeFrom(
          from._internal_by_entity());
      break;
    }
    case kByType: {
      _this->_internal_mutable_by_type()->::gie::PropertyPartitionByTypeStrategy::MergeFrom(
          from._internal_by_type());
      break;
    }
    case ITEM_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:gie.GraphPropertyPartitionStrategy)
}

inline void GraphPropertyPartitionStrategy::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.item_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_item();
}

GraphPropertyPartitionStrategy::~GraphPropertyPartitionStrategy() {
  // @@protoc_insertion_point(destructor:gie.GraphPropertyPartitionStrategy)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GraphPropertyPartitionStrategy::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_item()) {
    clear_item();
  }
}

void GraphPropertyPartitionStrategy::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GraphPropertyPartitionStrategy::clear_item() {
// @@protoc_insertion_point(one_of_clear_start:gie.GraphPropertyPartitionStrategy)
  switch (item_case()) {
    case kByEntity: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.item_.by_entity_;
      }
      break;
    }
    case kByType: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.item_.by_type_;
      }
      break;
    }
    case ITEM_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ITEM_NOT_SET;
}


void GraphPropertyPartitionStrategy::Clear() {
// @@protoc_insertion_point(message_clear_start:gie.GraphPropertyPartitionStrategy)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_item();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GraphPropertyPartitionStrategy::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .gie.PropertyPartitionByEntityStrategy by_entity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_by_entity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .gie.PropertyPartitionByTypeStrategy by_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_by_type(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GraphPropertyPartitionStrategy::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gie.GraphPropertyPartitionStrategy)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .gie.PropertyPartitionByEntityStrategy by_entity = 1;
  if (_internal_has_by_entity()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::by_entity(this),
        _Internal::by_entity(this).GetCachedSize(), target, stream);
  }

  // .gie.PropertyPartitionByTypeStrategy by_type = 2;
  if (_internal_has_by_type()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::by_type(this),
        _Internal::by_type(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gie.GraphPropertyPartitionStrategy)
  return target;
}

size_t GraphPropertyPartitionStrategy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gie.GraphPropertyPartitionStrategy)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (item_case()) {
    // .gie.PropertyPartitionByEntityStrategy by_entity = 1;
    case kByEntity: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.item_.by_entity_);
      break;
    }
    // .gie.PropertyPartitionByTypeStrategy by_type = 2;
    case kByType: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.item_.by_type_);
      break;
    }
    case ITEM_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GraphPropertyPartitionStrategy::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GraphPropertyPartitionStrategy::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GraphPropertyPartitionStrategy::GetClassData() const { return &_class_data_; }


void GraphPropertyPartitionStrategy::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GraphPropertyPartitionStrategy*>(&to_msg);
  auto& from = static_cast<const GraphPropertyPartitionStrategy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gie.GraphPropertyPartitionStrategy)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.item_case()) {
    case kByEntity: {
      _this->_internal_mutable_by_entity()->::gie::PropertyPartitionByEntityStrategy::MergeFrom(
          from._internal_by_entity());
      break;
    }
    case kByType: {
      _this->_internal_mutable_by_type()->::gie::PropertyPartitionByTypeStrategy::MergeFrom(
          from._internal_by_type());
      break;
    }
    case ITEM_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GraphPropertyPartitionStrategy::CopyFrom(const GraphPropertyPartitionStrategy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gie.GraphPropertyPartitionStrategy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GraphPropertyPartitionStrategy::IsInitialized() const {
  return true;
}

void GraphPropertyPartitionStrategy::InternalSwap(GraphPropertyPartitionStrategy* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.item_, other->_impl_.item_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata GraphPropertyPartitionStrategy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gie_5fschema_2eproto_getter, &descriptor_table_gie_5fschema_2eproto_once,
      file_level_metadata_gie_5fschema_2eproto[2]);
}

// ===================================================================

class GraphPartitionStrategy::_Internal {
 public:
  static const ::gie::GraphPropertyPartitionStrategy& property(const GraphPartitionStrategy* msg);
};

const ::gie::GraphPropertyPartitionStrategy&
GraphPartitionStrategy::_Internal::property(const GraphPartitionStrategy* msg) {
  return *msg->_impl_.property_;
}
GraphPartitionStrategy::GraphPartitionStrategy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gie.GraphPartitionStrategy)
}
GraphPartitionStrategy::GraphPartitionStrategy(const GraphPartitionStrategy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GraphPartitionStrategy* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.property_){nullptr}
    , decltype(_impl_.topology_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_property()) {
    _this->_impl_.property_ = new ::gie::GraphPropertyPartitionStrategy(*from._impl_.property_);
  }
  _this->_impl_.topology_ = from._impl_.topology_;
  // @@protoc_insertion_point(copy_constructor:gie.GraphPartitionStrategy)
}

inline void GraphPartitionStrategy::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.property_){nullptr}
    , decltype(_impl_.topology_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GraphPartitionStrategy::~GraphPartitionStrategy() {
  // @@protoc_insertion_point(destructor:gie.GraphPartitionStrategy)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GraphPartitionStrategy::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.property_;
}

void GraphPartitionStrategy::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GraphPartitionStrategy::Clear() {
// @@protoc_insertion_point(message_clear_start:gie.GraphPartitionStrategy)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.property_ != nullptr) {
    delete _impl_.property_;
  }
  _impl_.property_ = nullptr;
  _impl_.topology_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GraphPartitionStrategy::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .gie.GraphTopologyPartitionStrategy topology = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_topology(static_cast<::gie::GraphTopologyPartitionStrategy>(val));
        } else
          goto handle_unusual;
        continue;
      // .gie.GraphPropertyPartitionStrategy property = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_property(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GraphPartitionStrategy::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gie.GraphPartitionStrategy)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .gie.GraphTopologyPartitionStrategy topology = 1;
  if (this->_internal_topology() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_topology(), target);
  }

  // .gie.GraphPropertyPartitionStrategy property = 2;
  if (this->_internal_has_property()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::property(this),
        _Internal::property(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gie.GraphPartitionStrategy)
  return target;
}

size_t GraphPartitionStrategy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gie.GraphPartitionStrategy)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .gie.GraphPropertyPartitionStrategy property = 2;
  if (this->_internal_has_property()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.property_);
  }

  // .gie.GraphTopologyPartitionStrategy topology = 1;
  if (this->_internal_topology() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_topology());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GraphPartitionStrategy::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GraphPartitionStrategy::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GraphPartitionStrategy::GetClassData() const { return &_class_data_; }


void GraphPartitionStrategy::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GraphPartitionStrategy*>(&to_msg);
  auto& from = static_cast<const GraphPartitionStrategy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gie.GraphPartitionStrategy)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_property()) {
    _this->_internal_mutable_property()->::gie::GraphPropertyPartitionStrategy::MergeFrom(
        from._internal_property());
  }
  if (from._internal_topology() != 0) {
    _this->_internal_set_topology(from._internal_topology());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GraphPartitionStrategy::CopyFrom(const GraphPartitionStrategy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gie.GraphPartitionStrategy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GraphPartitionStrategy::IsInitialized() const {
  return true;
}

void GraphPartitionStrategy::InternalSwap(GraphPartitionStrategy* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GraphPartitionStrategy, _impl_.topology_)
      + sizeof(GraphPartitionStrategy::_impl_.topology_)
      - PROTOBUF_FIELD_OFFSET(GraphPartitionStrategy, _impl_.property_)>(
          reinterpret_cast<char*>(&_impl_.property_),
          reinterpret_cast<char*>(&other->_impl_.property_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GraphPartitionStrategy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gie_5fschema_2eproto_getter, &descriptor_table_gie_5fschema_2eproto_once,
      file_level_metadata_gie_5fschema_2eproto[3]);
}

// ===================================================================

class SrcDstPair::_Internal {
 public:
};

SrcDstPair::SrcDstPair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gie.SrcDstPair)
}
SrcDstPair::SrcDstPair(const SrcDstPair& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SrcDstPair* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.src_type_){}
    , decltype(_impl_.dst_type_){}
    , decltype(_impl_.partition_strategy_){}
    , decltype(_impl_.property_partition_strategy_){}
    , decltype(_impl_.relation_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.src_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.src_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_src_type().empty()) {
    _this->_impl_.src_type_.Set(from._internal_src_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.dst_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dst_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_dst_type().empty()) {
    _this->_impl_.dst_type_.Set(from._internal_dst_type(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.partition_strategy_, &from._impl_.partition_strategy_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.relation_) -
    reinterpret_cast<char*>(&_impl_.partition_strategy_)) + sizeof(_impl_.relation_));
  // @@protoc_insertion_point(copy_constructor:gie.SrcDstPair)
}

inline void SrcDstPair::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.src_type_){}
    , decltype(_impl_.dst_type_){}
    , decltype(_impl_.partition_strategy_){0}
    , decltype(_impl_.property_partition_strategy_){0}
    , decltype(_impl_.relation_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.src_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.src_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dst_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dst_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SrcDstPair::~SrcDstPair() {
  // @@protoc_insertion_point(destructor:gie.SrcDstPair)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SrcDstPair::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.src_type_.Destroy();
  _impl_.dst_type_.Destroy();
}

void SrcDstPair::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SrcDstPair::Clear() {
// @@protoc_insertion_point(message_clear_start:gie.SrcDstPair)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.src_type_.ClearToEmpty();
  _impl_.dst_type_.ClearToEmpty();
  ::memset(&_impl_.partition_strategy_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.relation_) -
      reinterpret_cast<char*>(&_impl_.partition_strategy_)) + sizeof(_impl_.relation_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SrcDstPair::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string src_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_src_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gie.SrcDstPair.src_type"));
        } else
          goto handle_unusual;
        continue;
      // string dst_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_dst_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gie.SrcDstPair.dst_type"));
        } else
          goto handle_unusual;
        continue;
      // .gie.EdgePartitionStrategy partition_strategy = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_partition_strategy(static_cast<::gie::EdgePartitionStrategy>(val));
        } else
          goto handle_unusual;
        continue;
      // .gie.PropertyPartitionStrategy property_partition_strategy = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_property_partition_strategy(static_cast<::gie::PropertyPartitionStrategy>(val));
        } else
          goto handle_unusual;
        continue;
      // .gie.Relation relation = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_relation(static_cast<::gie::Relation>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SrcDstPair::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gie.SrcDstPair)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string src_type = 1;
  if (!this->_internal_src_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_src_type().data(), static_cast<int>(this->_internal_src_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gie.SrcDstPair.src_type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_src_type(), target);
  }

  // string dst_type = 2;
  if (!this->_internal_dst_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_dst_type().data(), static_cast<int>(this->_internal_dst_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gie.SrcDstPair.dst_type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_dst_type(), target);
  }

  // .gie.EdgePartitionStrategy partition_strategy = 3;
  if (this->_internal_partition_strategy() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_partition_strategy(), target);
  }

  // .gie.PropertyPartitionStrategy property_partition_strategy = 4;
  if (this->_internal_property_partition_strategy() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_property_partition_strategy(), target);
  }

  // .gie.Relation relation = 5;
  if (this->_internal_relation() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_relation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gie.SrcDstPair)
  return target;
}

size_t SrcDstPair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gie.SrcDstPair)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string src_type = 1;
  if (!this->_internal_src_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_src_type());
  }

  // string dst_type = 2;
  if (!this->_internal_dst_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_dst_type());
  }

  // .gie.EdgePartitionStrategy partition_strategy = 3;
  if (this->_internal_partition_strategy() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_partition_strategy());
  }

  // .gie.PropertyPartitionStrategy property_partition_strategy = 4;
  if (this->_internal_property_partition_strategy() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_property_partition_strategy());
  }

  // .gie.Relation relation = 5;
  if (this->_internal_relation() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_relation());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SrcDstPair::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SrcDstPair::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SrcDstPair::GetClassData() const { return &_class_data_; }


void SrcDstPair::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SrcDstPair*>(&to_msg);
  auto& from = static_cast<const SrcDstPair&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gie.SrcDstPair)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_src_type().empty()) {
    _this->_internal_set_src_type(from._internal_src_type());
  }
  if (!from._internal_dst_type().empty()) {
    _this->_internal_set_dst_type(from._internal_dst_type());
  }
  if (from._internal_partition_strategy() != 0) {
    _this->_internal_set_partition_strategy(from._internal_partition_strategy());
  }
  if (from._internal_property_partition_strategy() != 0) {
    _this->_internal_set_property_partition_strategy(from._internal_property_partition_strategy());
  }
  if (from._internal_relation() != 0) {
    _this->_internal_set_relation(from._internal_relation());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SrcDstPair::CopyFrom(const SrcDstPair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gie.SrcDstPair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SrcDstPair::IsInitialized() const {
  return true;
}

void SrcDstPair::InternalSwap(SrcDstPair* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.src_type_, lhs_arena,
      &other->_impl_.src_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dst_type_, lhs_arena,
      &other->_impl_.dst_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SrcDstPair, _impl_.relation_)
      + sizeof(SrcDstPair::_impl_.relation_)
      - PROTOBUF_FIELD_OFFSET(SrcDstPair, _impl_.partition_strategy_)>(
          reinterpret_cast<char*>(&_impl_.partition_strategy_),
          reinterpret_cast<char*>(&other->_impl_.partition_strategy_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SrcDstPair::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gie_5fschema_2eproto_getter, &descriptor_table_gie_5fschema_2eproto_once,
      file_level_metadata_gie_5fschema_2eproto[4]);
}

// ===================================================================

class Property::_Internal {
 public:
};

Property::Property(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gie.Property)
}
Property::Property(const Property& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Property* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:gie.Property)
}

inline void Property::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.id_){0u}
    , decltype(_impl_.type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Property::~Property() {
  // @@protoc_insertion_point(destructor:gie.Property)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Property::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void Property::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Property::Clear() {
// @@protoc_insertion_point(message_clear_start:gie.Property)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.type_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.type_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Property::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gie.Property.name"));
        } else
          goto handle_unusual;
        continue;
      // .gie.DataType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::gie::DataType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Property::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gie.Property)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gie.Property.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // .gie.DataType type = 3;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gie.Property)
  return target;
}

size_t Property::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gie.Property)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
  }

  // .gie.DataType type = 3;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Property::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Property::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Property::GetClassData() const { return &_class_data_; }


void Property::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Property*>(&to_msg);
  auto& from = static_cast<const Property&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gie.Property)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Property::CopyFrom(const Property& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gie.Property)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Property::IsInitialized() const {
  return true;
}

void Property::InternalSwap(Property* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Property, _impl_.type_)
      + sizeof(Property::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(Property, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Property::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gie_5fschema_2eproto_getter, &descriptor_table_gie_5fschema_2eproto_once,
      file_level_metadata_gie_5fschema_2eproto[5]);
}

// ===================================================================

class VertexType::_Internal {
 public:
};

VertexType::VertexType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gie.VertexType)
}
VertexType::VertexType(const VertexType& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VertexType* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.properties_){from._impl_.properties_}
    , decltype(_impl_.primary_keys_){from._impl_.primary_keys_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.partition_strategy_){}
    , decltype(_impl_.total_num_){}
    , decltype(_impl_.property_partition_strategy_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.property_partition_strategy_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.property_partition_strategy_));
  // @@protoc_insertion_point(copy_constructor:gie.VertexType)
}

inline void VertexType::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.properties_){arena}
    , decltype(_impl_.primary_keys_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.id_){0u}
    , decltype(_impl_.partition_strategy_){0}
    , decltype(_impl_.total_num_){int64_t{0}}
    , decltype(_impl_.property_partition_strategy_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VertexType::~VertexType() {
  // @@protoc_insertion_point(destructor:gie.VertexType)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VertexType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.properties_.~RepeatedPtrField();
  _impl_.primary_keys_.~RepeatedPtrField();
  _impl_.name_.Destroy();
}

void VertexType::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VertexType::Clear() {
// @@protoc_insertion_point(message_clear_start:gie.VertexType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.properties_.Clear();
  _impl_.primary_keys_.Clear();
  _impl_.name_.ClearToEmpty();
  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.property_partition_strategy_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.property_partition_strategy_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VertexType::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gie.VertexType.name"));
        } else
          goto handle_unusual;
        continue;
      // repeated .gie.Property properties = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string primary_keys = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_primary_keys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "gie.VertexType.primary_keys"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .gie.VertexPartitionStrategy partition_strategy = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_partition_strategy(static_cast<::gie::VertexPartitionStrategy>(val));
        } else
          goto handle_unusual;
        continue;
      // .gie.PropertyPartitionStrategy property_partition_strategy = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_property_partition_strategy(static_cast<::gie::PropertyPartitionStrategy>(val));
        } else
          goto handle_unusual;
        continue;
      // int64 total_num = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.total_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VertexType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gie.VertexType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gie.VertexType.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // repeated .gie.Property properties = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_properties(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string primary_keys = 4;
  for (int i = 0, n = this->_internal_primary_keys_size(); i < n; i++) {
    const auto& s = this->_internal_primary_keys(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gie.VertexType.primary_keys");
    target = stream->WriteString(4, s, target);
  }

  // .gie.VertexPartitionStrategy partition_strategy = 5;
  if (this->_internal_partition_strategy() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_partition_strategy(), target);
  }

  // .gie.PropertyPartitionStrategy property_partition_strategy = 6;
  if (this->_internal_property_partition_strategy() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_property_partition_strategy(), target);
  }

  // int64 total_num = 7;
  if (this->_internal_total_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_total_num(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gie.VertexType)
  return target;
}

size_t VertexType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gie.VertexType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gie.Property properties = 3;
  total_size += 1UL * this->_internal_properties_size();
  for (const auto& msg : this->_impl_.properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string primary_keys = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.primary_keys_.size());
  for (int i = 0, n = _impl_.primary_keys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.primary_keys_.Get(i));
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
  }

  // .gie.VertexPartitionStrategy partition_strategy = 5;
  if (this->_internal_partition_strategy() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_partition_strategy());
  }

  // int64 total_num = 7;
  if (this->_internal_total_num() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_total_num());
  }

  // .gie.PropertyPartitionStrategy property_partition_strategy = 6;
  if (this->_internal_property_partition_strategy() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_property_partition_strategy());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VertexType::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VertexType::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VertexType::GetClassData() const { return &_class_data_; }


void VertexType::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VertexType*>(&to_msg);
  auto& from = static_cast<const VertexType&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gie.VertexType)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.properties_.MergeFrom(from._impl_.properties_);
  _this->_impl_.primary_keys_.MergeFrom(from._impl_.primary_keys_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_partition_strategy() != 0) {
    _this->_internal_set_partition_strategy(from._internal_partition_strategy());
  }
  if (from._internal_total_num() != 0) {
    _this->_internal_set_total_num(from._internal_total_num());
  }
  if (from._internal_property_partition_strategy() != 0) {
    _this->_internal_set_property_partition_strategy(from._internal_property_partition_strategy());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VertexType::CopyFrom(const VertexType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gie.VertexType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VertexType::IsInitialized() const {
  return true;
}

void VertexType::InternalSwap(VertexType* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.properties_.InternalSwap(&other->_impl_.properties_);
  _impl_.primary_keys_.InternalSwap(&other->_impl_.primary_keys_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VertexType, _impl_.property_partition_strategy_)
      + sizeof(VertexType::_impl_.property_partition_strategy_)
      - PROTOBUF_FIELD_OFFSET(VertexType, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VertexType::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gie_5fschema_2eproto_getter, &descriptor_table_gie_5fschema_2eproto_once,
      file_level_metadata_gie_5fschema_2eproto[6]);
}

// ===================================================================

class EdgeType::_Internal {
 public:
};

EdgeType::EdgeType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gie.EdgeType)
}
EdgeType::EdgeType(const EdgeType& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EdgeType* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.properties_){from._impl_.properties_}
    , decltype(_impl_.primary_keys_){from._impl_.primary_keys_}
    , decltype(_impl_.src_dst_pairs_){from._impl_.src_dst_pairs_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.total_num_){}
    , decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.total_num_, &from._impl_.total_num_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.id_) -
    reinterpret_cast<char*>(&_impl_.total_num_)) + sizeof(_impl_.id_));
  // @@protoc_insertion_point(copy_constructor:gie.EdgeType)
}

inline void EdgeType::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.properties_){arena}
    , decltype(_impl_.primary_keys_){arena}
    , decltype(_impl_.src_dst_pairs_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.total_num_){int64_t{0}}
    , decltype(_impl_.id_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EdgeType::~EdgeType() {
  // @@protoc_insertion_point(destructor:gie.EdgeType)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EdgeType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.properties_.~RepeatedPtrField();
  _impl_.primary_keys_.~RepeatedPtrField();
  _impl_.src_dst_pairs_.~RepeatedPtrField();
  _impl_.name_.Destroy();
}

void EdgeType::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EdgeType::Clear() {
// @@protoc_insertion_point(message_clear_start:gie.EdgeType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.properties_.Clear();
  _impl_.primary_keys_.Clear();
  _impl_.src_dst_pairs_.Clear();
  _impl_.name_.ClearToEmpty();
  ::memset(&_impl_.total_num_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.id_) -
      reinterpret_cast<char*>(&_impl_.total_num_)) + sizeof(_impl_.id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EdgeType::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "gie.EdgeType.name"));
        } else
          goto handle_unusual;
        continue;
      // repeated .gie.Property properties = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string primary_keys = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_primary_keys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "gie.EdgeType.primary_keys"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .gie.SrcDstPair src_dst_pairs = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_src_dst_pairs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int64 total_num = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.total_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EdgeType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gie.EdgeType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gie.EdgeType.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // repeated .gie.Property properties = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_properties(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string primary_keys = 4;
  for (int i = 0, n = this->_internal_primary_keys_size(); i < n; i++) {
    const auto& s = this->_internal_primary_keys(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "gie.EdgeType.primary_keys");
    target = stream->WriteString(4, s, target);
  }

  // repeated .gie.SrcDstPair src_dst_pairs = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_src_dst_pairs_size()); i < n; i++) {
    const auto& repfield = this->_internal_src_dst_pairs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int64 total_num = 6;
  if (this->_internal_total_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_total_num(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gie.EdgeType)
  return target;
}

size_t EdgeType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gie.EdgeType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gie.Property properties = 3;
  total_size += 1UL * this->_internal_properties_size();
  for (const auto& msg : this->_impl_.properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string primary_keys = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.primary_keys_.size());
  for (int i = 0, n = _impl_.primary_keys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.primary_keys_.Get(i));
  }

  // repeated .gie.SrcDstPair src_dst_pairs = 5;
  total_size += 1UL * this->_internal_src_dst_pairs_size();
  for (const auto& msg : this->_impl_.src_dst_pairs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // int64 total_num = 6;
  if (this->_internal_total_num() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_total_num());
  }

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EdgeType::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EdgeType::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EdgeType::GetClassData() const { return &_class_data_; }


void EdgeType::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EdgeType*>(&to_msg);
  auto& from = static_cast<const EdgeType&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gie.EdgeType)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.properties_.MergeFrom(from._impl_.properties_);
  _this->_impl_.primary_keys_.MergeFrom(from._impl_.primary_keys_);
  _this->_impl_.src_dst_pairs_.MergeFrom(from._impl_.src_dst_pairs_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_total_num() != 0) {
    _this->_internal_set_total_num(from._internal_total_num());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EdgeType::CopyFrom(const EdgeType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gie.EdgeType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EdgeType::IsInitialized() const {
  return true;
}

void EdgeType::InternalSwap(EdgeType* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.properties_.InternalSwap(&other->_impl_.properties_);
  _impl_.primary_keys_.InternalSwap(&other->_impl_.primary_keys_);
  _impl_.src_dst_pairs_.InternalSwap(&other->_impl_.src_dst_pairs_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EdgeType, _impl_.id_)
      + sizeof(EdgeType::_impl_.id_)
      - PROTOBUF_FIELD_OFFSET(EdgeType, _impl_.total_num_)>(
          reinterpret_cast<char*>(&_impl_.total_num_),
          reinterpret_cast<char*>(&other->_impl_.total_num_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EdgeType::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gie_5fschema_2eproto_getter, &descriptor_table_gie_5fschema_2eproto_once,
      file_level_metadata_gie_5fschema_2eproto[7]);
}

// ===================================================================

class Statistics::_Internal {
 public:
};

Statistics::Statistics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gie.Statistics)
}
Statistics::Statistics(const Statistics& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Statistics* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.num_vertices_){}
    , decltype(_impl_.num_edges_){}
    , decltype(_impl_.num_partitions_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.num_vertices_, &from._impl_.num_vertices_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_partitions_) -
    reinterpret_cast<char*>(&_impl_.num_vertices_)) + sizeof(_impl_.num_partitions_));
  // @@protoc_insertion_point(copy_constructor:gie.Statistics)
}

inline void Statistics::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.num_vertices_){uint64_t{0u}}
    , decltype(_impl_.num_edges_){uint64_t{0u}}
    , decltype(_impl_.num_partitions_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Statistics::~Statistics() {
  // @@protoc_insertion_point(destructor:gie.Statistics)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Statistics::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Statistics::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Statistics::Clear() {
// @@protoc_insertion_point(message_clear_start:gie.Statistics)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.num_vertices_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.num_partitions_) -
      reinterpret_cast<char*>(&_impl_.num_vertices_)) + sizeof(_impl_.num_partitions_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Statistics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 num_partitions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.num_partitions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 num_vertices = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.num_vertices_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 num_edges = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.num_edges_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Statistics::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gie.Statistics)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 num_partitions = 1;
  if (this->_internal_num_partitions() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_num_partitions(), target);
  }

  // uint64 num_vertices = 2;
  if (this->_internal_num_vertices() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_num_vertices(), target);
  }

  // uint64 num_edges = 3;
  if (this->_internal_num_edges() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_num_edges(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gie.Statistics)
  return target;
}

size_t Statistics::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gie.Statistics)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 num_vertices = 2;
  if (this->_internal_num_vertices() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_num_vertices());
  }

  // uint64 num_edges = 3;
  if (this->_internal_num_edges() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_num_edges());
  }

  // uint32 num_partitions = 1;
  if (this->_internal_num_partitions() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_partitions());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Statistics::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Statistics::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Statistics::GetClassData() const { return &_class_data_; }


void Statistics::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Statistics*>(&to_msg);
  auto& from = static_cast<const Statistics&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gie.Statistics)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_num_vertices() != 0) {
    _this->_internal_set_num_vertices(from._internal_num_vertices());
  }
  if (from._internal_num_edges() != 0) {
    _this->_internal_set_num_edges(from._internal_num_edges());
  }
  if (from._internal_num_partitions() != 0) {
    _this->_internal_set_num_partitions(from._internal_num_partitions());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Statistics::CopyFrom(const Statistics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gie.Statistics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Statistics::IsInitialized() const {
  return true;
}

void Statistics::InternalSwap(Statistics* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Statistics, _impl_.num_partitions_)
      + sizeof(Statistics::_impl_.num_partitions_)
      - PROTOBUF_FIELD_OFFSET(Statistics, _impl_.num_vertices_)>(
          reinterpret_cast<char*>(&_impl_.num_vertices_),
          reinterpret_cast<char*>(&other->_impl_.num_vertices_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Statistics::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gie_5fschema_2eproto_getter, &descriptor_table_gie_5fschema_2eproto_once,
      file_level_metadata_gie_5fschema_2eproto[8]);
}

// ===================================================================

class Schema::_Internal {
 public:
  static const ::gie::GraphPartitionStrategy& partition_strategy(const Schema* msg);
  static const ::gie::Statistics& statistics(const Schema* msg);
};

const ::gie::GraphPartitionStrategy&
Schema::_Internal::partition_strategy(const Schema* msg) {
  return *msg->_impl_.partition_strategy_;
}
const ::gie::Statistics&
Schema::_Internal::statistics(const Schema* msg) {
  return *msg->_impl_.statistics_;
}
Schema::Schema(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:gie.Schema)
}
Schema::Schema(const Schema& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Schema* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.vertex_types_){from._impl_.vertex_types_}
    , decltype(_impl_.edge_types_){from._impl_.edge_types_}
    , decltype(_impl_.partition_strategy_){nullptr}
    , decltype(_impl_.statistics_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_partition_strategy()) {
    _this->_impl_.partition_strategy_ = new ::gie::GraphPartitionStrategy(*from._impl_.partition_strategy_);
  }
  if (from._internal_has_statistics()) {
    _this->_impl_.statistics_ = new ::gie::Statistics(*from._impl_.statistics_);
  }
  // @@protoc_insertion_point(copy_constructor:gie.Schema)
}

inline void Schema::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.vertex_types_){arena}
    , decltype(_impl_.edge_types_){arena}
    , decltype(_impl_.partition_strategy_){nullptr}
    , decltype(_impl_.statistics_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Schema::~Schema() {
  // @@protoc_insertion_point(destructor:gie.Schema)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Schema::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vertex_types_.~RepeatedPtrField();
  _impl_.edge_types_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.partition_strategy_;
  if (this != internal_default_instance()) delete _impl_.statistics_;
}

void Schema::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Schema::Clear() {
// @@protoc_insertion_point(message_clear_start:gie.Schema)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.vertex_types_.Clear();
  _impl_.edge_types_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.partition_strategy_ != nullptr) {
    delete _impl_.partition_strategy_;
  }
  _impl_.partition_strategy_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.statistics_ != nullptr) {
    delete _impl_.statistics_;
  }
  _impl_.statistics_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Schema::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .gie.GraphPartitionStrategy partition_strategy = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_partition_strategy(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .gie.VertexType vertex_types = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_vertex_types(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .gie.EdgeType edge_types = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_edge_types(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .gie.Statistics statistics = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_statistics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Schema::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:gie.Schema)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .gie.GraphPartitionStrategy partition_strategy = 1;
  if (this->_internal_has_partition_strategy()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::partition_strategy(this),
        _Internal::partition_strategy(this).GetCachedSize(), target, stream);
  }

  // repeated .gie.VertexType vertex_types = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_vertex_types_size()); i < n; i++) {
    const auto& repfield = this->_internal_vertex_types(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .gie.EdgeType edge_types = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_edge_types_size()); i < n; i++) {
    const auto& repfield = this->_internal_edge_types(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .gie.Statistics statistics = 4;
  if (this->_internal_has_statistics()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::statistics(this),
        _Internal::statistics(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gie.Schema)
  return target;
}

size_t Schema::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:gie.Schema)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .gie.VertexType vertex_types = 2;
  total_size += 1UL * this->_internal_vertex_types_size();
  for (const auto& msg : this->_impl_.vertex_types_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .gie.EdgeType edge_types = 3;
  total_size += 1UL * this->_internal_edge_types_size();
  for (const auto& msg : this->_impl_.edge_types_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .gie.GraphPartitionStrategy partition_strategy = 1;
  if (this->_internal_has_partition_strategy()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.partition_strategy_);
  }

  // .gie.Statistics statistics = 4;
  if (this->_internal_has_statistics()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.statistics_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Schema::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Schema::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Schema::GetClassData() const { return &_class_data_; }


void Schema::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Schema*>(&to_msg);
  auto& from = static_cast<const Schema&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:gie.Schema)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.vertex_types_.MergeFrom(from._impl_.vertex_types_);
  _this->_impl_.edge_types_.MergeFrom(from._impl_.edge_types_);
  if (from._internal_has_partition_strategy()) {
    _this->_internal_mutable_partition_strategy()->::gie::GraphPartitionStrategy::MergeFrom(
        from._internal_partition_strategy());
  }
  if (from._internal_has_statistics()) {
    _this->_internal_mutable_statistics()->::gie::Statistics::MergeFrom(
        from._internal_statistics());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Schema::CopyFrom(const Schema& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gie.Schema)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Schema::IsInitialized() const {
  return true;
}

void Schema::InternalSwap(Schema* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.vertex_types_.InternalSwap(&other->_impl_.vertex_types_);
  _impl_.edge_types_.InternalSwap(&other->_impl_.edge_types_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Schema, _impl_.statistics_)
      + sizeof(Schema::_impl_.statistics_)
      - PROTOBUF_FIELD_OFFSET(Schema, _impl_.partition_strategy_)>(
          reinterpret_cast<char*>(&_impl_.partition_strategy_),
          reinterpret_cast<char*>(&other->_impl_.partition_strategy_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Schema::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gie_5fschema_2eproto_getter, &descriptor_table_gie_5fschema_2eproto_once,
      file_level_metadata_gie_5fschema_2eproto[9]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace gie
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::gie::PropertyPartitionByEntityStrategy*
Arena::CreateMaybeMessage< ::gie::PropertyPartitionByEntityStrategy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gie::PropertyPartitionByEntityStrategy >(arena);
}
template<> PROTOBUF_NOINLINE ::gie::PropertyPartitionByTypeStrategy*
Arena::CreateMaybeMessage< ::gie::PropertyPartitionByTypeStrategy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gie::PropertyPartitionByTypeStrategy >(arena);
}
template<> PROTOBUF_NOINLINE ::gie::GraphPropertyPartitionStrategy*
Arena::CreateMaybeMessage< ::gie::GraphPropertyPartitionStrategy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gie::GraphPropertyPartitionStrategy >(arena);
}
template<> PROTOBUF_NOINLINE ::gie::GraphPartitionStrategy*
Arena::CreateMaybeMessage< ::gie::GraphPartitionStrategy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gie::GraphPartitionStrategy >(arena);
}
template<> PROTOBUF_NOINLINE ::gie::SrcDstPair*
Arena::CreateMaybeMessage< ::gie::SrcDstPair >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gie::SrcDstPair >(arena);
}
template<> PROTOBUF_NOINLINE ::gie::Property*
Arena::CreateMaybeMessage< ::gie::Property >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gie::Property >(arena);
}
template<> PROTOBUF_NOINLINE ::gie::VertexType*
Arena::CreateMaybeMessage< ::gie::VertexType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gie::VertexType >(arena);
}
template<> PROTOBUF_NOINLINE ::gie::EdgeType*
Arena::CreateMaybeMessage< ::gie::EdgeType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gie::EdgeType >(arena);
}
template<> PROTOBUF_NOINLINE ::gie::Statistics*
Arena::CreateMaybeMessage< ::gie::Statistics >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gie::Statistics >(arena);
}
template<> PROTOBUF_NOINLINE ::gie::Schema*
Arena::CreateMaybeMessage< ::gie::Schema >(Arena* arena) {
  return Arena::CreateMessageInternal< ::gie::Schema >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
